<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		GO DOWN TO THE JOURNAL ENTRIES SECTION BELOW
		(look for more rows of asterisks)


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->


<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, posted on Brightspace.  

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<!--<base href="https://engineering.purdue.edu/ece477/StudentWebTemplate/" />-->
    <base href="https://engineering.purdue.edu/477grp15/" /> <!-- Replace the N with your team number-->

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="Files/img/BannerImgExample.jpg"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		
		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		JOURNAL ENTRIES BELOW
		Make your Journal Entries in the template area below and copy/past going forward


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->
		
		<div id="content">
            <h2>Project Journal for Caleb Shinkle</h2>
			<h2>===============   Week 11: =================</h2>
	<!--  Week 11, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: April 9th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Had a little time to code, so I started making a Bus struct to cleanly wrap all of the needed GPIO pins into something that tram can use. However, I quickly realized that it is not as simple as designating certain pins as inputs, and other pins as outputs. For example, when executing a memory read, the data lines on the bus should be outputs in tram, so data can be send back to the CPU. However, when executing a memory write, the data lines are inputs to tram so recall can write the data to memory. Since this is the case, I just listed all of our bus signals as AnyPins, which is a way to define the type as a GPIO pin without committing to input/output yet. For future reference, I also added comments to each signal which details its corresponding IO pin number.
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_5.1.png" alt="code" width="600"></img>
			<br><br>
			When interfacing two packages in a main file, I will have to declare a Bus struct and assign the variables to GPIO pins. Having this framework means that I am getting closer to completing all of tram’s interfaces, I just need to finish it and figure out how to call PIO routines to get the bus timings we need. 
			<br><br>
			Next week, I plan on looking into how to assign the pins dynamically (change input/output based on need), and I also need to figure out how to block any other packages from modifying the bus while a request is active (waiting on response).
			<br><br><br><br>
	<!--  Week 11, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: April 8th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started looking into how to detect memory requests on the GPIO pins so that tram can translate them into Messages. In tram, I wrote some skeleton code for a detect_memory_request() function, which will return a summary of the bus signals. Once I figure out how to use the embassy-rp framework a bit better, I can monitor the GPIO pins and assign the values to a BusState struct, which is a middle step in translating GPIO to Messages. It contains the values on the address and data lines, as well as boolean flags for each Message type (is the bus state a read request? write request? etc.). I also added some aliases TX and RX for sender and receiver channels for readability and ease of use. 
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.2.png" alt="code" width="600"></img>
			<br><br>
			Inside of recall’s main loop, I call tram.detect_memory_request(), which returns the current bus state. Then I check the boolean flags of the bus state to determine what kind of request is active, if any. If there is a request, the corresponding message is sent over the channel to recall, and recall will respond accordingly. The updated main loop can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.3.png" alt="code" width="600"></img>
			<br><br>
			This should just about complete the recall-tram interface, so I should be able to transfer most of this logic to the other packages. We are getting closer to being able to test all of our software packages together, which is a huge step in our project.
			<br><br>
			Since the tram attached to recall can just poll incoming GPIO pins (for request detection), the next step is to find a clean way to wrap all of the GPIO pins into a struct that detect_memory_request() can check. This is much easier than passing every single GPIO pin individually to the function. Later tonight I’ll try and get something figured out.
			<br><br><br><br>
	<!--  Week 13, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: April 7th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I spent this time attempting to get recall to build (updated with the interface to tram) as well as cleaning up the code. After running cargo build, I was getting an error that told me that std::sync::mpsc::channel could not be found. This was because, as I should have noticed earlier, features of the std library cannot be used in no_std environments, which we are using. In our dependencies, I saw the embassy-sync package, which happened to provide channels very similar to the ones I was trying to use, documentation for those below:
			<br><br>
			<a href="https://github.com/embassy-rs/embassy/blob/main/embassy-sync/src/channel.rs">embassy-sync channels</a>
			<br><br>
			After reading through the documentation, I redefined the TX and RX in the lib.rs files in each package, using the first Mutex that I found since I was unsure what they actually did, which can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.1.png" alt="code" width="600"></img>
			<br><br>
			I then updated the send_msg() and recv_msg() functions in the tram and recall structs themselves. Since the embassy-sync channel’s send/recv functions are async functions, I updated the send_msg()/recv_msg() functions to be async functions and used .await to get the async functionality of send/recv (seen below)
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.3.png" alt="code" width="600"></img>
			<br><br>
			The final step of reworking this was to define the channels to be used inside of recall’s main.rs file. These channels needed to be defined as static and were created using the Channel::new() function provided by embassy. The code for this can be seen below with updated imports/dependencies.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.4.png" alt="code" width="600"></img>
			<br><br>
			I decided that I didn’t like having an individual lib.rs file in each package that needed updated every time I made a change, so I defined a common package to be used by packages that need it, which contains its own lib.rs file. This way, when I need to change something that is used by all packages, I can just modify this single lib.rs file, which is much easier. I had to update the Cargo.toml file in each package to support this, but that was as simple as adding the line “common = {workspace=true}” under the [dependencies] section. 
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.6.png" alt="code" width="600"></img>
			<br><br>
			I tried to build this before I had to go to class, and I was getting the error messages seen below. I will try and figure this out tomorrow night. As soon as this gets done, I should be able to get recall to build, which means that we can begin testing it soon (which would mean having 1 out of 4 major packages finished). We desperately need to start working on the CPU emulator (runner package), so I will move on to that as soon as recall builds.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.7.png" alt="code" width="600"></img>
			<br><br><br><br>
			<h2>===============   Week 12: =================</h2>
			<b>I was in Pittsburgh, PA for club gymnastics nationals this week, so no work was done</b>
			<h2>===============   Week 11: =================</h2>
	<!--  Week 11, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:15pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 0.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Had a little time to code, so I started making a Bus struct to cleanly wrap all of the needed GPIO pins into something that tram can use. However, I quickly realized that it is not as simple as designating certain pins as inputs, and other pins as outputs. For example, when executing a memory read, the data lines on the bus should be outputs in tram, so data can be send back to the CPU. However, when executing a memory write, the data lines are inputs to tram so recall can write the data to memory. Since this is the case, I just listed all of our bus signals as AnyPins, which is a way to define the type as a GPIO pin without committing to input/output yet. For future reference, I also added comments to each signal which details its corresponding IO pin number.
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_5.1.png" alt="code" width="600"></img>
			<br><br>
			When interfacing two packages in a main file, I will have to declare a Bus struct and assign the variables to GPIO pins. Having this framework means that I am getting closer to completing all of tram’s interfaces, I just need to finish it and figure out how to call PIO routines to get the bus timings we need. 
			<br><br>
			Next week, I plan on looking into how to assign the pins dynamically (change input/output based on need), and I also need to figure out how to block any other packages from modifying the bus while a request is active (waiting on response).
			<br><br><br><br>
	<!--  Week 11, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started looking into how to detect memory requests on the GPIO pins so that tram can translate them into Messages. In tram, I wrote some skeleton code for a detect_memory_request() function, which will return a summary of the bus signals. Once I figure out how to use the embassy-rp framework a bit better, I can monitor the GPIO pins and assign the values to a BusState struct, which is a middle step in translating GPIO to Messages. It contains the values on the address and data lines, as well as boolean flags for each Message type (is the bus state a read request? write request? etc.). I also added some aliases TX and RX for sender and receiver channels for readability and ease of use. 
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.2.png" alt="code" width="600"></img>
			<br><br>
			Inside of recall’s main loop, I call tram.detect_memory_request(), which returns the current bus state. Then I check the boolean flags of the bus state to determine what kind of request is active, if any. If there is a request, the corresponding message is sent over the channel to recall, and recall will respond accordingly. The updated main loop can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.3.png" alt="code" width="600"></img>
			<br><br>
			This should just about complete the recall-tram interface, so I should be able to transfer most of this logic to the other packages. We are getting closer to being able to test all of our software packages together, which is a huge step in our project.
			<br><br>
			Since the tram attached to recall can just poll incoming GPIO pins (for request detection), the next step is to find a clean way to wrap all of the GPIO pins into a struct that detect_memory_request() can check. This is much easier than passing every single GPIO pin individually to the function. Later tonight I’ll try and get something figured out.
			<br><br><br><br>
	<!--  Week 11, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 12:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Worked on coding up the ideas I came up with in lab, trying to keep it clean and scalable so that my teammates can understand it. Referring to the stuff I drew on the whiteboard, I started setting up channels by adding a send and receive channel to both the recall and tram structs, then adding functions to send and receive messages over the channel, using the .send() and .recv() functions of std::sync::mpsc::channel, documentation below:
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send">std::sync::mpsc::channel.send() - Rust</a>
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv">std::sync::mpsc::channel.send() - Rust</a>
			<br><br>
			The updated code for tram and recall with the above functionality can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.2.png" alt="code" width="600"></img>
			<br><br>
			I also made an attempt at connecting the channels together in recall’s main function, and I also wrote some rough code for how recall is going to respond to messages. I’m not exactly sure if this will work but my idea is this: call tram’s.recv_msg() function (returns an Option<Message>), if there is a message, use a match {} block to figure out what the message is, then either call read() or write(). Nowhere near final code, but it can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.3.png" alt="code" width="600"></img>
			<br><br>
			I’m going to keep working on this tomorrow, as soon as it is done I want to move on to getting GPIO stuff working using the embassy-rp framework. I need to look into what GPIO signals can be used to detect memory requests, and how to translate what is on the GPIO pins into a Message to send to recall. Getting this working and tested would be great progress, since I can use the same logic to work on the other two packages (CPU emulator and front panel software)
			<br><br><br><br>
	<!--  Week 11, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: March 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on cleaning up the code from yesterday, then I realized that a lot of the ideas I came up with yesterday could be useful for much more than prototyping. I saw that the channels could be used exclusively for communication between tram and other packages, and that I could do something similar to the BusMessage struct to send over the channels. Formally, tram will listen for bus changes, detect memory requests, and translate the GPIO signals into a message struct to pass to packages. A sketch of this behavior can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_2.1.jpg" alt="whiteboard" width="600"></img>
			<br><br>
			I talked this over with Seth a bit, and we both agreed that this could work. Also had to meet with the instructors so I didn’t get a whole lot of time to modify the code just yet, but I wrote down a bunch of my ideas in our Discord so I can work on it later. I had a meeting to attend so I had to leave lab early, so I’ll revisit the code later today. I thought about what recall needs to know to respond to memory requests, so I came up with a more abstract Message struct to pass between recall and tram. Tram detects memory request on GPIO, then passes a Message over the channel connecting recall and tram, and recall responds to that message. Here’s the message struct and some of the types I will need for now:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_2.2.png" alt="code" width="600"></img>
			<br><br>
			I now understand how all of our code is going to interface, which is a huge step in the right direction and I should be able to get a lot of code done soon. There are still a few details that still need figured out, which include: 1) how can I use PIO to generate proper timings on GPIO pins for read/write cycles?  and 2) how can I block the bus when there is an active request?
			<br><br><br><br>
	<!--  Week 11, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 25th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I started brainstorming on how to simulate the communication between tram and recall (bus control and memory emulator). I started by drawing a crude diagram on the white board for how our software packages will interact, then I started thinking about how to simulate the communication without using any GPIO stuff just to make sure the packages could communicate properly (following our software architecture diagram, seen below)
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.1.JPG" alt="sw architecture" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.2.jpg" alt="sw interface" width="600"></img>
			<br><br>
			After that I just started writing some code to make a rough interface between tram and recall. I thought that instead of using our actual bus, I could just create some structs for requests and responses to pass between packages. This would allow me to test if the packages could communicate properly until I figure out exactly which bus signals correspond to memory requests and responses.
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.3.png" alt="code1" width="600"></img>
			<br><br>
			I also wrote some rough code in the main loop of recall to constantly poll for requests. My first idea was that tram would have some kind of receive() function, which would return a request or response if there was one active, and would return nothing otherwise (using the std::Option<T> feature, documentation below).
			<br><br>
			<a href="https://doc.rust-lang.org/std/option/">std::option - Rust</a>
			<br><br>
			I haven’t figured out exact details at this point, but if recall gets a request through tram, it will then call its read()/write() functions and generate a response to send back to tram. With this setup tram can handle machine cycles (to get the exact timings we need for reads and writes), and recall is completely blind to them (just calls its local read()/write() and responds to tram). The skeleton code I wrote can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.4.png" alt="code2" width="600"></img>
			<br><br>
			For passing these messages between packages, I found something called channels, which allows me to set up tx and rx channels to pass any data type I want (for our purposes, the BusMessage struct from earlier). For example, I have structs that define Tram and Recall, so I can just add a tx and rx member to them, then connect the channels together in the main function to allow bidirectional communication of BusMessages between the two through the channels.
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">std::sync::mpsc::channel - Rust</a>
			<br><br>
			Finally, I created a TramSim struct to simulate tram’s behavior for now without any bus/GPIO stuff. I added the tx/rx channels described above, I’ll figure out how to connect them to recall tomorrow
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.5.png" alt="code3" width="600"></img>
			<br><br>
			To summarize today’s work, I wrote on the whiteboard and coded some Rust to figure out how to prototype the communication interface between tram and recall. With a little more code connecting tram and recall in recall’s main function, I should be able to send an abstract BusRequest to tram, and recall should act accordingly and send a response back to tram. Since our software architecture dictates that tram is the only thing directly interacting with the bus, getting this figured out means that I can transfer similar logic to our CPU emulator and front panel software, and I should be able to get a full simulation of interfaces between all packages done soon (ignoring bus/GPIO stuff for now for simplicity).
			<br><br>
			In terms of next steps, I want to clean up this code a bit and fully complete the logic so I can start testing it. Once I can test this interface and verify that it’s going to work, I will move on to getting the other side of tram (GPIO/bus interface) figured out. This will involve figuring out which bus signals correspond to read/write requests, and eventually figuring out how to use PIO to get the bus timings we are looking for.
			<br><br><br><br>
			<h2>===============   Week 10: =================</h2>
	<!--  Week 10, Entry 4  -->
	<h4><b>Spring Break, no work this week!</b></h4>
			<br><br><br><br>
			<h2>===============   Week 9: =================</h2>
	<!--  Week 9, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: March 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 6:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on getting the Stamp XL boards connected to a breadboard. Had to hot glue everything to a piece of cardboard for now, but I was able to get all of the pins for one board connected using jumper cables. I was busy packing for spring break so I didn't have time to connect the other one yet, but I was thinking I can at least start debugging some tram stuff using only one board and an Analog Discovery 2, just to see if the timings are looking correct. 
			<br>
			<img src="Team/journal/img - member3/week9/W9_4.1.jpg" alt="crude test harness" width="600"></img>
			<br>
			Once I get settled on break, I will begin writing some tram code and try debugging it on the test harness. Getting tram working is a big hurdle in our project, so setting up to test it is a big step in the right direction. With my free time next week, I hope to come back with a working version of tram that can be tested with our other software. 
			<br><br><br><br>
	<!--  Week 9, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: March 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Went into lab for a bit to solder the other board. I used the lab station soldering iron, and things went a lot smoother this time (it took me half the time of the first one). I soldered it a bit differently this time such that every pad I tried to solder was easily accessible, and by tinning the iron more frequently, the end result was a lot cleaner than the first time. After I was done soldering, I did the same electrical continuity test that I did last time, and everything looked good. Some pictures of the soldered board can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.1.jpg" alt="board 2 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.2.jpg" alt="board 2 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.3.jpg" alt="board 2 solder" width="600"></img>
			<br>
			Now that both boards are soldered, I just need to hook them up to a breadboard to complete the test harness, which will allow me to start testing code over break. Assumming I make good progress over break, we should be able to come together as team after break and get our software working in the coming weeks, which is the last major milestone in this project. 
			<br><br><br><br>
	<!--  Week 9, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: March 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, the instructors looked over some of the Rust code I had written for our memory emulator, and they said that the read() and write() functions looked good. I spent the rest of the time researching PIO so that I can start writing tram next week once my test harness is set up. Most of my research was done by reading the PIO section of the RP2350 datasheet, linked below:
			<br>
			<a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">RP2350 Datasheet</a>
			<br>
			The state machine overview, which can be seen below, helped me understand how to use PIO. There are two scratch registers X and Y, and you just write assembly-type instructions in PIO routines to control the I/O. The RP2350B provides 12 of these state machines in total, so I plan to use as many of these as possible for our bus control implementation (tram). The instrucitons that can be used to control these state machines can also be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.1.png" alt="state machine overview" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.3.png" alt="PIO instructions" width="600"></img>
			<br>
			The datasheet also provided a simple example routine to use as guidance, which generates a simple square wave. It accomplishes this by setting a pin as output, then setting the pin high, waiting, setting the pin low, then repeating. The structure is extremely similar to other assembly variants like RISC-V, so it should be easy for me to extend this example to get the timings that we need for tram signals.
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.2.png" alt="PIO instructions" width="600"></img>
			<br>
			To understand how to use these PIO routines to implement tram, I had to talk with Seth to understand how tram interfaces with our other software packages (CPU emulator, RAM emulator, etc.). We went through some general functionality together, then I created my own flowcahrt with pseudocode to describe the communication of CPU/RAM through tram, which can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.4.jpg" alt="pesudocode" width="600"></img>
			<br>
			This reinforced my understanding that I gained last week while working on the software overview in our presentation. Tram will listen to bus signals from the CPU/RAM emulators, then execute machine cycles (different from clock cycles) to send requests and responses as necessary. As a result of this, I feel like I have a good enough understanding to start coding next week once I have my test harness finished. Once tram is at least partially functional, we can start testing it with the other software packages driving it, which is a huge step in bringing our project together.
			<br><br><br><br>
	<!--  Week 9, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 11th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started the process of setting up my test harness to take on spring break with me. The first step was to solder one of the Stamp XL boards to the Stamp Carrier XL, as well as soldering the pin headers and power connector. I had to first learn how to solder by looking it up online and asking my teammates for tips. I then attempted to solder the Stamp XL board, and it was a bit rough since I am just learning to solder. I ended up messing up on the 12-pin connector on the edge of the board, so I had to desolder it which took a lot longer than I would have thought. The solder ended up filling one of the pin holes, and it was extremely painful to remove. Some images of the completed soldering can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_1.1.jpg" alt="board 1 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_1.2.jpg" alt="board 1 solder" width="600"></img>
			<br>
			The 12-pin edge connector was not completely functional as can be seen in the picture, but all of the pins that I need to start testing recall (memory emulator) should be functional. I did a continuity test using the multimeter and moving along the pins to test for good electrical connection. This is a bit of a detour from the main project, but it will set me up nicely to get some good debugging done while I'm away for spring break next week. The next steps are to a) solder the other board, and b) connect both boards to a breadboard to complete the test harness. 
			<br>
			I also started coding a prototype version of our memory emulator (Recall). Instead of communicating with tram, it will just use GPIO pins to simulate tram signals so that I can debug recall-specific funcitonality. I had to look into designating pins as inputs/outputs using the Embassy framework, but it's pretty simple code as of right now. It is currently incomplete, but I plan to keep working on it next week and test it on the test harness I'm working on. Prototyping recall like this will at least help us make sure that it works correctly before connecting it to tram, which will make debugging easier once we do. 
			<br><br><br><br>
			
			<h2>===============   Week 8: =================</h2>
	<!--  Week 8, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 4th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Tonight I worked on the midterm design review presentation, specifically most of the general overview as well as the software section. I did this by using the midterm design review template presentation and modifying the sections to better suit our project. I decided to go into more detail than required on the software since our project is extremely software heavy, and most of our debugging will be in software rather than hardware. In order to do this, I had to do a bit of research about our software structure and how all the packages will interact. Since I had been focused on writing the memory emulator, I had never looked into how tram (our bus control package) interacts with everything. After reading the diagrams and descriptions that Brian wrote, I understood what tram is trying to accomplish. Effectively, it just watches the bus 24/7 and moderates the completion of machine cycles. Machine cycles can be reads/writes to memory, and they take multiple clock cycles to complete. Credit to Brian for these timing diagrams, we are going to use PIO routines and some Rust code to try and get the following timings for reads/writes on our system. 
			<br>
			<img src="Team/journal/img - member3/week9/W8_1.JPG" alt="timing" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W8_2.JPG" alt="timing" width="600"></img>
			<br>
			It took me around 3 hours to write the 17 slides as I had to gather images from our project, look into the specs of all of our components, and write a lot of details on our software packages. This also required around 1 hour of research on our bus control, then I practiced my portion of the presentation once to make sure I was ready. This contributes to project progress by giving the instructors a good detailed overview of our progress thus far, as well as helping me understand how to begin implementing tram. After the presentation, our main focus will be making progress towards having working software, so I will need to research PIO a bit to figure out exactly how we are going to implement tram. With spring break coming up, I ordered my own RP2350 Stamp XL boards that I can set up my own test harness with. This way I can take that on break with me to test/debug software. 
			<br>
			<a href="https://lectronz.com/products/rp2350-stamp-xl">RP235x Stamp XL Board</a>
			<br><br><br><br>
			
			<h2>===============   Week 7: =================</h2>
	<!--  Week 7, Entry 6  -->
	<h4><b>Entry 6: -----------------------------------------------------------------</b></h4>
           <b>Date: February 28th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:15am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Had a brief team meeting this morning, found out that Seth did in fact get embassy-rp working again, and he was able to flash a blinky LED test case to the micro, and the code inside the main loop actually executed. Since I have a good idea of where our software stands after this week, I started working on the software section of the presentation for next week. I did realize that some of the documentation on our website could use some updates, so I started on that by implementing some of the feedback on A3 - Software Overview. As a result I feel somewhat prepared for the presentation next week, and I have a very good overview of our software that I can easily explain to my teammates when we all work on debugging later this semester.
			<br><br><br><br>
	<!--  Week 7, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: February 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on auditing the rp235x-hal code to support functionality of all 47 GPIO pins on the RP2350B QFN80 package. After reading through most of the repository and RP2350B datasheet (~1 hour), I saw a lot of changes that needed to be made to the UART, I2C, and GPIO sections of the code. Copying the existing framework, I added code to allow UART and I2C functionality to all GPIO pins, and I also enable the pins in GPIO/func.rs.
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.png" alt="datasheet excerpt" width="600"></img>
			<br>
			Now that this is done, I can meet with the team tomorrow morning and try and use the updated rp235x-hal package. Hopefully we can get the code to flash to the micro and we can begin debugging our software. This week has felt like a lot of running into issues, but I think we are moving in the right direction. Worst case scenario, if Seth gets embassy-rp working again, we can always have this as a backup if embassy-rp runs into issues down the road (its RP2350 support is relatively new so I wouldn’t be surprised). Some of the changes to the rp235x-hal code I had to make can be seen below:
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.2.png" alt="website update" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.3.png" alt="website update" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.4.png" alt="website update" width="600"></img>
			<br>
			<br><br><br><br>
	<!--  Week 7, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: February 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Went into lab to try and flash the memory emulator package to one of the prototyping boards on our test harness with the new embassy-rp setup. I first had to move all of my code from eceprog to a WSL environment to use the USB connection for flashing. After realizing that WSL still couldn’t use the USB cable, I had to look into mounting the USB device to WSL. This required some PowerShell commands, but I was able to get the WSL environment to flash my code to the micro. 
			<br>
			<img src="Team/journal/img - member3/week7/W7J4.png" alt="website update" width="600"></img>
			<br>
			We did run into a pretty big issue, which was that the code would flash to the micro and everything looked good, except nothing in the main loop would actually execute. Although rp235x-hal didn’t support all the pins we needed, we were able to flash to the micros with it and the code in the main loop would execute. We decided that I am going to try and add functionality for all 47 GPIO pins in rp235x-hal, and Seth is going to try and fix whatever issues we have with embassy-rp. We now have 2 people working on debugging software issues and 2 people finishing up PCB layouts, so we should be able to fix these issues soon and start finalizing our CPU/memory emulators.
			<br><br><br><br>		
	<!--  Week 7, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:15pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			As I suspected, there was a slight issue with the dependencies in Cargo.toml, but I was able to get it resolved by explicitly stating the version of ‘embassy-time-driver’ as 0.2.0. This did take some around 30 minutes to read through documentation specific to embassy-time, and about 20 minutes to resolve the issue in Cargo.toml. 
			<br>
			<a href="https://github.com/embassy-rs/embassy/tree/main/embassy-rp">embassy-rp repository</a>
			<br>
			 I was working on my computer at home, so I wasn’t able to try flashing to the microcontroller. I also had some issues with the code I had written in main.rs, so after reading more embassy documentation the code was able to build. If we just copy this setup to the other Rust packages we’re writing (CPU emulator, bus control), we should be able to get those flashed and tested in the next couple weeks, so we’re making progress towards software verification.
			<br>
			<br>
			<br><br>
	<!--  Week 7, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, we first met with the instructors, who told us that our new functional description was much better, but that our PSDRs could be a little bit more clear. I then spent around 30 minutes talking with the team and making the PSDRs on the team website more understandable. As a result, the website’s front page should be completely done and all details about our project should be very easy for anyone who reads it to understand.
			<br>
			<img src="Team/journal/img - member3/week7/W7J2.JPG" alt="website update" width="600"></img>
			<br>
			After that, we kept reading through the rp235x-hal repository, and recognized that some of the functionality only had support for the QFN60 package of the RP2350, and not the QFN80 package. For example, UART was only configured for GPIO pins 0-29, but pins 30-47 were not set up. Luckily, we found a replacement for this in the embassy-rp repository, which is another open-source HAL for the RP2350, and this one had support built-in for all pins on the QFN80 package. 
			<br>
			<a href="https://github.com/embassy-rs/embassy/tree/main/embassy-rp">embassy-rp repository</a>
			<br>
			The setup process was almost exactly the same as for rp235x-hal, so I just needed to add embassy-rp stuff as dependencies in the Cargo.toml and cargo.config files. Integrating embassy-rp with the emulator was very similar to rp235x-hal, some code from main.rs can be seen below:
			<br>
			<img src="Team/journal/img - member3/week7/W7J1.JPG" alt="website update" width="600"></img>
			<br>
			After trying to build the code towards the end of lab section, I ran into a configuration error that can be seen below. Something was wrong with our dependencies (likely in Cargo.toml), so the project wouldn’t build or flash to the micro. I had to go to class so I couldn’t get this fixed in lab, but it should be an easy fix. In terms of project progress, this was a small step back, but we should be able to get this resolved and have support for the QFN80 package of our RP2350.
			<br>
			<img src="Team/journal/img - member3/week7/W7J3.png" alt="build error" width="600"></img>
			<br><br><br><br>
	<!--  Week 7, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Decided to start working on the microcontroller-specific programming for the memory emulator. I first had to spend about 45 minutes reading through the rp235x-hal repository to understand how to code with the macros and packages for the RP2350. The top-level README in the rp-hal repository was very helpful with getting it setup and providing examples for how to structure my code.
			<br>
			<a href="https://github.com/rp-rs/rp-hal/tree/main/rp235x-hal">rp235x-hal repository</a>
			<br>
			Then, I had to modify the Cargo.toml and cargo.config files in the emulator’s directory so that the code would build. Took a bit to figure out, but I just had to add some stuff under [dependencies] in Cargo.toml to get the code to build. After integrating the rp235x_hal package with main.rs, I was able to get the code to build on my local machine. However, since I was on eceprog on my laptop (which didn’t support communication over the USB cable we’re using to flash), I was unable to get the emulator flashed to our prototyping board.
			<br>
			Doing this is a big step in our project since getting this set up allows us to start flashing code to the microcontrollers, meaning that using our test harness, we can start doing some basic tests with the CPU/memory emulators and the bus controller (called tram in our project), which are their own separate cargo workspaces meaning they can be flashed to different micros independently.
			<br>
			<br><br><br>

			
			<h2>===============   Week 6: =================</h2>				
	<!--  Week 6, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 21st </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 2:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			Started coding the emulator that will run on our memory card. Using Rust, I wrote some code to execute the read/write functions of memory. Using test functions, I am able to read and write to “addresses” in memory, which are really just indexes to a stack allocated array that holds bytes. The read() function takes a 16 bit address as an argument, and returns the byte located at that address (8 bits). The write() function takes an 8 bit value to write and a 16 bit address, and updates the array with the input byte at the index provided (no return value). Since the read and write functions work, the next step is to get the emulator to use bus signals to call read/write so it can actually function as memory for our system.  I didn’t quite get time to figure out what bus signals that the emulator needs to respond to, so I will need to look into the S100 bus a bit more deeply this weekend to figure out which signals need to be asserted by the CPU/memory emulators to handle reads/writes. I found a good resource that describes some of the signals needed for memory operations, I'll read it more thoroughly in the next couple days but a helpful excerpt can be seen below:
			<br>
			<img src="Team/journal/img - member3/week6/Week6J3.JPG" alt="mem flowchart" width="600"></img>
			<br>
 			I will need to figure out which IO pins we are putting MWrite, PWR, SMEMR, and PDBIN on and write my code accordingly. I will also be looking at the IEEE standard to guide my implementation, link below
			<br>
			<a href="http://www.s100computers.com/General%20Images/ieee696spec.pdf">IEEE standard of S100 bus</a>
			<br>
			<br>
			<br><br>
			
	<!--  Week 6, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 20th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 4:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			After realizing that we will need to emulate memory as well instead of using normal memory chips, I started thinking about how to emulate memory. The simplest approach seems to be using another RP2350B chip on a board exactly like the CPU card, but running a memory emulator instead. I read through the rs80 repository (linked in week 5 journal) some more, then made a basic flowchart for the memory emulator operation, seen below. The emulator will need to listen to the bus for read/write signals, then respond accordingly. Unlike the CPU emulator, the memory emulator will have its own clock so that it can constantly listen to bus signals.
			<br>
			<img src="Team/journal/img - member3/week6/Week5J2_memflow.JPG" alt="mem flowchart" width="600"></img>
			<br>
			We probably will be using a basic stack-allocated array to act as memory, but the emulator will need to respond to bus signals to control reads/writes. Keeping the emulator as simple as possible (basically just an array) will hopefully help us with easy debugging. Tomorrow I am going to start coding the emulator a bit, hopefully I can get basic read/write functionality done. Getting the memory emulator done would allow us to start using our test harness to figure out our bus implementation.
			<br><br><br><br>
	<!--  Week 6, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 18th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, we met with the instructors and figured out that our PSDRs were still not up to standard, and that we all have a slightly different idea of how our project is going to function. I spent a good amount of time talking with Seth about how we are going to handle software, and realized that we need an emulator for memory to run on a second card. I really didn’t get much work done during this time, but I feel like talking with the group changed the way I am going to approach the software implementation. Seth explained our test harness, which is two RP2350s hooked up to a breadboard, so we can run one with the CPU emulator and one with the memory emulator, so we can easily debug our emulators/bus. I’ll probably start thinking about the memory emulator implementation soon. The test harness we will be using to debug emulators/bus stuff can be seen below:
			<br>
			<img src="Team/journal/img - member3/week6/Week6J1_harness.jpg" alt="test harness" width="600"></img>
			<br>
			<br><br><br>
			<h2>===============   Week 5: =================</h2>				
	<!--  Week 5, Entry 4 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
          <b>Date: February 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 6:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
		Spent this time researching the S100 bus a bit, and also looked into how programming on the original Altair 8800 works. I did this by reading some of the IEEE standard for the S100 bus and watching some YouTube videos in a playlist called “Altair 8800 Instructional Videos” about how to program on the Altair 8800, which our project is trying to mimic.  I learned how the various switches on the front panel operate, including the examine switch for examining memory locations and the deposit switch for putting values in memory. I also read about the voltage levels on the original S100 bus, which were some pretty exotic levels including +/-16V, 8V, and +/-5V. The modifications we will make for our project include running everything on 3.3V and using DDR4 DIMM connectors in place of the original 100-pin connectors, although we will be not be using all 288 pins that the connectors provide (less than 100 probably for our desired functionality). I'll draw a rough sketch of the backplane PCB so it is clearer in my mind, seen below.
			<br>
			<img src="Team/journal/img - member3/week5/Week5J4.JPG" alt="backplane rough schematic" width="600"></img>
			<br>
		 Since we now have our RP2350 stamp boards, the next step is getting some Rust running on them so we can start emulating CPU/memory/UART for our functionality cards.
			<br>
		<a href="http://www.s100computers.com/General%20Images/ieee696spec.pdf">Link to IEEE standard of S100 bus</a>
			<br>
		<a href="https://www.youtube.com/watch?v=suyiMfzmZKs&list=PLB3mwSROoJ4KLWM8KwK0cD1dhX35wILBj">Link to Altair 8800 tutorials</a>
			<br><br><br><br>
			
	<!--  Week 5, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: February 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		Spent this time working on updating our website since our functional description was severely lacking in detail. To accomplish this, I just worked directly in our GitHub repository (specifically the index.html file) that is synced to our website (screenshot of some of the modifications I made below). I ended up finishing significantly more detailed functional descriptions of all of our major components, and I also revised our PSDRs to include more detail. This gave me, my teammates, and the instructors a better idea of what we are actually trying to accomplish with our project, which will help all of us in the long run.  
			<br>
			<img src="Team/journal/img - member3/week5/Week5J3.JPG" alt="backplane rough schematic" width="600"></img>
			<br>
		Since I don’t think any of us know super specific details about the bus for our project, I plan on doing some research later today on how the S100 bus actually functions and how we need to modify it for our project.
			<br><br><br><br>
	<!--  Week 5, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		During this lab section, we had our weekly meeting with the instructors, who gave us some good feedback on our functional description and PSDRs. In terms of actual work, I was mostly catching up with the team to see where everyone was at and figuring out how things were coming together. We are working on getting some Rust code flashed to the microcontroller as well as prototyping the front panel with LEDs and switches. I spent the rest of the time researching what dependencies and packages we need to use to get an emulator running on the RP2350 micros. After meeting with the team and instructors, we realized that our functional description on the website was severely lacking in detail, so I plan on setting some time aside later this week to overhaul it. 
			<br>
			<br>
			<br><br>		
	<!--  Week 5, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 10th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		Having learned Rust in the last few weeks, I spent more time reading through the rs80 repository that we are using as reference to better understand how to use Rust for CPU emulation. As a result I have a better understanding of the data types we will be using and how they will work together to emulate the Intel 8080 instruction set. I have an exam later this week so I’m not super focused on doing too much work for our project for the first half of this week, but I will be doing a lot more research later this week to figure out how we are going to emulate CPU, RAM, and UART as I’m sure they will be handled slightly differently.
			<br>
		<a href="https://github.com/cbiffle/rs80">Link to reference Rust emulator</a>
			<br>
			<br><br><br>
			
		    <!-- (just copy/paste for Week 3 and going forward  --> 
			
			<h2>===============   Week 4: =================</h2>				
	<!--  Week 4, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 7 </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 4:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
		During this time I finished my portion of A5 and researched the S100 bus a bit more. I did so by writing in Word and reading the Wikipedia article about the S100 bus. It was hard to find some of the more technical details, but as a result I understand the bus we are trying to implement better. In terms of project progress, I feel ready to start prototyping with muliple RP2350s to try and get a crude bus prototype. Next week, we will begin actually prototyping and trying to get multiple components working together, such as CPU emulator and memory.
			<br>
			<br>
			<br><br>
			
	<!--  Week 4, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 7th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		We met in lab to work on A5 and starting to prototype on a breadboard. I spent most of my time writing for A5 on Word, and I talked with my teammates to figure out some details. I made good progress on A5, and I better understand why we chose the RP2350 over other STM or ESP micros. This contributes to project progress by fulfilling a required assignment and helping me understand what we are using each component for. The next step is to finish A5 and start working on prototyping/bus stuff next week.  
			<br>
			<br>
			<br><br>
			
	<!--  Week 4, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 2nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 12:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		I spent a good amount of time reading and understanding the specs of the RP2350B microcontroller, which we will be using for our project. I did so by reading the datasheet online. As a result I have a better understanding of how our MCUs will interface with other components of our project, and I have a better idea of how to approach our S100-inspired bus. This contributes to our progress because we can now start working on the finer details of bus implementation. We should start prototypying once we get our MCUs and get working on our emulator next. 
			<br>
		
			<br>
			<br><br>
			    <h2>===============   Week 3: =================</h2>
 						
	<!--  Week 3, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: January 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<br>
			<br>
			<br><br>
    <h2>===============   Week 2: =================</h2>
 						
	<!--  Week 2, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: January 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            We met in lab and finalized/formalized our PSDRs, and they now include more specific details about the emulator. The emulator should support all instructions for the 8080 CPU and listen to the clock from the front panel, rather than having its own clock. The other PSDR we changed was with regards to the bus and how it should work. I also spent a little more time on Rustlings, nearly completing the training so I can start working on the emulator next week. Next week I will start working on the emulator and figure out how to achieve the desired frequency. The RP2350 is clocked at 150 MHz, but the Altair 8800 had a 2 MHz clock, so I will need to write the emulator such that roughly 75 emulator instructions execute 1 8080 instruction. 
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            During lab section we met with the course staff to discuss project progress and review our PSDRs. After lab, I spent around 1.5 hours starting to learn Rust through Rustlings, an open source tool for learning Rust. As a result, we figured out what we needed to change on our PSDRs, and I also got more comfortable programming in Rust. We now know what exactly our project milestones are, and I am nearly comfortable enough with Rust to start working on our 8080 emulator.
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 20th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            During this hour I did some research about which programming language I should use for the emulator. I researched by reading other developers opinions about Rust, since I have never used it before. After debating between C, C++, and Rust, I decided on using Rust because Rust is fast like C, but it is memory-safe, which will be good for the amount of memory manipulation that emulating requires. Since some of my group already knows Rust, they may be able to help with the emulator if necessary. This contributes to group progress because I can now start writing the emulator for our CPU. The next obvious step is to learn Rust and research CPU emulation.
			<br>
			<br>
			<br><br>
		   
    <h2>===============   Week 1: =================</h2>

	<!--  Week 1, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 17th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            We met as a team and formalized our various project milestones. We did this by listing desired functionality on the white board, then talking about what is necessary to acomplish the functionality. As a result, we were able to figure out more of what this project entails and assign team roles. This contributed to the team's progress by giving us a better idea of what exactly we need to do. Since I was assigned software lead, my next step is to look into writing an emulator for the Intel 8080 CPU, and to start writing it as soon as possible.
			<br>
			<br>
			<br><br>
			
	<!--  Week 1, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 15th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            This was our first lab meeting, so we spent half of the lab section learning about lab resources. The other half of the lab was discussing our project with the TAs and talking about project milestones within our group.
		We mostly just talked about rough milestone ideas without formalizing anything, but we got a rough idea of the various components of our project. This gave us a good foundation to do our own research and figure out exactly what all needed to be done.
		THe next step is to formalize our milestones and assign team roles, so we can start working on the various project components.
			<br>
			<br>
		 <br><br>


		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		JOURNAL ENTRIES ABOVE
		Make your Journal Entries in the template area above and copy/paste going forward


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->


        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
