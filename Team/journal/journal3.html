<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		GO DOWN TO THE JOURNAL ENTRIES SECTION BELOW
		(look for more rows of asterisks)


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->


<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, posted on Brightspace.  

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<!--<base href="https://engineering.purdue.edu/ece477/StudentWebTemplate/" />-->
    <base href="https://engineering.purdue.edu/477grp15/" /> <!-- Replace the N with your team number-->

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="Files/img/BannerImgExample.jpg"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		
		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		JOURNAL ENTRIES BELOW
		Make your Journal Entries in the template area below and copy/past going forward


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->
		
		<div id="content">
            <h2>Project Journal for Caleb Shinkle</h2>
			<h2>===============   Week 15: =================</h2>
	<!--  Week 15, Entry 8  -->
	<h4><b>Entry 8: -----------------------------------------------------------------</b></h4>
           <b>Date: April 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 1:45pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Talked with Brian for a bit about how the front panel buttons work, and realized that the spreadsheet of our GPIO pin mappings wasn’t completely accurate. According to the old spreadsheet, the buttons were just directly connected to the bus, but they actually need to go through the microcontroller on the front panel first. Referencing our schematic and PCB layout for the front panel, I updated the spreadsheet to reflect this, which will help me when writing the main front panel loop.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.2.png" alt="code" width="600"></img>
			<br><br>
			Spent some time experimenting with the skeleton code that Seth wrote for the front panel, trying mainly to figure out whether the buttons were pulled high or low (to determine low or high active reset, etc.). Running the program, I determined that pressing the buttons on the test harness changed the value from 1 to 0, indicating that the buttons are in fact pulled high when not active. When the button is pressed, the corresponding bit in the log drops from 1 to 0, which can be seen by the group of 4 bits dropping from 0xF to 0xE
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.3.png" alt="code" width="600"></img>
			<br><br>
			This is different from the PCB, where the buttons are high-active, so I will need to handle that at some point. In order to detect button presses, I will have to extract individual bits from the I2C’s GPIOA and GPIOB banks, which are 8 bits each. To begin, I had to look at the schematic to determine how each button was polled and where the result is stored
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.4.png" alt="code" width="600"></img>
			<br><br>
			I noticed that the test harness has the buttons and switches mapped differently, so I will not be able to use the test harness to test the front panel software. Instead, I will have to wait for Brian to solder a working backplane and front panel card, since the only working front panel card we have is in the machine shop right now. Using the schematic, I started rewriting the code that Seth set up to reflect the front panel PCB, cleaning up some naming stuff along the way to make it understandable. 
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.6.png" alt="code" width="600"></img>
			<br><br>
			I also started writing helper functions to extract each bit from the 8-bit I2C outputs so that I can detect individual button presses later. For instance, the RESET signal comes from bit 6 of the first I/O expander’s GPIOB bank, so I wrote a function to return the value present on that bit
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.7.png" alt="code" width="600"></img>
			<br><br>
			Inside the main loop, I will check the value on the reset button and assert the bus RESET signal if it is asserted. This will be repeated for all buttons on the front panel, but the logic will look something like this:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.8.png" alt="code" width="600"></img>
			<br><br>
			I want to just test pressing the RESET button to make sure that this framework is gonna work, but I’ll need to wait on Brian to finish soldering first as previously mentioned. In the meantime, I set up functions for extracting all the other button presses, very similar logic to get_reset() just with a different bit position.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.9.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_8.10.png" alt="code" width="600"></img>
			<br><br>
			The last thing I did before grabbing dinner was rewatch the Altair 8800 front panel programing video I watched earlier this semester (linked below). The better I can understand the front panel, the easier it will be to implement its functionality in software.
			<br><br>
			<a href="https://www.youtube.com/watch?v=EV1ki6LiEmg&list=PLB3mwSROoJ4KLWM8KwK0cD1dhX35wILBj&index=2">Altair 8800 Front Panel Programming Tutorial</a>
			<br><br>
			Here’s a summary of what I learned regarding deposit and deposit next: when the reset button is pressed, the front panel resets to address 0x0000. The first 8 address switches also act as the data line switches, so putting an opcode on the first 8 switches and pressing deposit will put that opcode at address 0x0000. Putting a new opcode on the switches and pressing deposit next will put that opcode at address 0x0001. Repeating this process will put an opcode at address 0x0002, and so on. Pressing single-step will then perform one fetch from memory. If the opcode requires 2 additional bytes of data, 2 more single-step presses will be required to finish the instruction. However, I may simplify this functionality for our design, and just have single-step execute a full instruction (automating the additional fetches).
			<br><br>
			Once Brian is done soldering, my next steps are testing what I currently have for front panel software, then continuing to write the main loop.
			<br><br><br><br>
	<!--  Week 15, Entry 7  -->
	<h4><b>Entry 7: -----------------------------------------------------------------</b></h4>
           <b>Date: April 23rd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:45pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Came up with a new game plan for getting something working for the demo on Friday. I am going to leave the memory attached to the CPU emulator so that I can just test front panel to CPU emulator communication without needing the bus transactions to fetch instructions/data. After brainstorming for a bit on how to accomplish this, I broke this plan down into two phases. Phase 1 is getting the CPU emulator running in a “run mode” on the microcontroller. When flashed, the emulator will just begin cycling through instructions preloaded into RAM and provide debugging info to the terminal. Phase 2 is writing the main loop for interchange (front panel software), then being able to control the CPU emulator with the buttons on the front panel (choose between single-step and run mode).
			<br><br>
			Starting phase 1, I made sure that the CPU emulator was ready to flash to the microcontroller. The package would build, but I had removed much of the debugging functionality, so I had to re-implement it in an embedded-friendly way to work with probe-rs. This involved changing any println!() calls to info!() calls, and changing the way I was handling displaying the CPU state. Instead of using fmt::Display, I had to write a function called show_state() as part of the CPU struct implementation. This function shows the same info as the old implementation, but using info!() calls. The code can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_7.1.png" alt="code" width="600"></img>
			<br><br>
			I added a call to this function in the main loop so that every time the emulator executes an instruction, the updated CPU state would be put on the terminal.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_7.2.png" alt="code" width="600"></img>
			<br><br>
			After verifying that the package builds, I started moving it to a Windows environment, since I have been working in a WSL environment, which I have not been able to get working with flashing code. I tried binding the USB device to WSL in the past using PowerShell commands, but to no avail. I had to install Rust and probe-rs on my local machine, then set up a GitHub SSH key to clone the rs repository. After doing this, I tried to run cargo run –bin emu (which should flash the emulator to the test harness), and I got a bunch of errors when trying to compile all the libraries. The fix to this was just copying the Cargo.toml file from a different, working package, which resolved the issue. After fixing that, which took much longer than it should have to figure out, I was able to flash and run the emulator. I preloaded RAM with a single HLT instruction, and the debugging output I got can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_7.3.png" alt="code" width="600"></img>
			<br><br>
			After verifying that the emulator would run on the micro, I started moving on to phase 2 of the plan, which was writing and testing the front panel main loop. I was able to get the code to flash to our test harness, but I was getting a panic() error with the I2C lines. After unplugging and replugging in the I2C wires, the code would run as intended but the switches weren’t doing anything. After working with Seth to figure this out, we found that the pull was wrong in the software (they were pulled low instead of high, as we had previously been testing on the actual front panel board where the pull is high). The change in code was changing the 0x00s to 0xFFs, the updated code can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_7.4.png" alt="code" width="600"></img>
			<br><br>
			After fixing this, the loop ran as intended, and the debugger would log the current state of the switches to the terminal
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_7.5.png" alt="code" width="600"></img>
			<br><br>
			The goal tomorrow is to get my simplified version of our project fully working, then spend whatever time we have left trying to figure out bus transactions with accurate timing. Steps for tomorrow include writing the main loop for interchange, updating the main loop in the cpu emulator to handle GPIO signals from front panel, and testing everything with different programs preloaded into RAM. Integration is coming along, I am confident we can get stuff working by our demo on Friday. 
			<br><br><br><br>
	<!--  Week 15, Entry 6  -->
	<h4><b>Entry 6: -----------------------------------------------------------------</b></h4>
           <b>Date: April 23rd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Wrote some helper functions in an attempt to clean up the code in execute_instruction() a bit. These functions retrieve either one or two bytes from memory starting at self.pc + 1, depending on what the instruction requires. The theory behind this is that when I need to update the code to do actual bus transactions, I will only need to modify the helper functions, nothing in execute_instruction().
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.1.png" alt="code" width="600"></img>
			<br><br>
			I went through execute_instruction() and replaced code with these helper functions as appropriate, which took a good amount of time but will be a great help later. With the remaining time I wrote and tested some test cases for various instructions. Starting with LXI rp,d16, I wrote the following test case and got the following output, which looks perfect to me:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.3.png" alt="code" width="600"></img>
			<br><br>
			Next I wrote a test case to test all of the MVI reg,d8 instructions. This was similar in structure to the test case for LXI rp,d16. After running all the instructions and examining the CPU state, all of the values from the test case were present in the appropriate registers, indicating that the instruction works as intended.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.4.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.5.png" alt="code" width="600"></img>
			<br><br>
			I also wrote a simple test case for JMP a16, which is the unconditional jump instruction. It fetches the two bytes after the opcode and updates the PC to that value to continue execution, and I wrote a test case that reflected this. Single-stepping through the execution, I found that it had the correct behavior.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.6.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.7.png" alt="code" width="600"></img>
			<br><br>
			The last test case that I wrote was for CALL a16 and RET, as these instructions are designed to work together. CALL puts the pc value at which to resume execution on the stack, then jumps to a subroutine. After the subroutine executes, RET is called and the pc value is popped off the stack and execution is resumed there. My test case does exactly this, jumping to a subroutine containing 3 NOPs then a RET, after RET there is an INR B instruction and HLT that should execute. Observing the execution flow, these instructions appear to work properly
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.8.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_6.9.png" alt="code" width="600"></img>
			<br><br>
			Given that the logic is more or less the same for conditional and unconditional JMP/CALL/RET, I can assume that those work fine as well. If there is a bug in those it will be as simple as fixing the broken flag-check condition. Testing this code is good progress because it will reduce the amount of debugging I need to do later today once I start testing on the real hardware.
			<br><br><br><br>
	<!--  Week 15, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: April 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Decided to go back and implement the remainder of the 8080 instructions in execute_instruction() so that once I start testing, I can use any instructions that I want. I once again referenced the 8080 opcodes table and Intel 8080 programmer's manual to accomplish this. I started with the jump instructions, specifically JMP a16, which is an unconditional jump to the address specified by a16. It needs 2 bytes of data (located at pc+1 and pc+2), then it updates the pc to whatever was retrieved from memory. The code I wrote can be seen below:
			<br><br>
			<a href="https://www.pastraiser.com/cpu/i8080/i8080_opcodes.html">8080 Opcodes</a>
			<br><br>
			<a href="https://altairclone.com/downloads/manuals/8080%20Programmers%20Manual.pdf">Programmer's Manual</a>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.1.png" alt="code" width="600"></img>
			<br><br>
			I then moved on to the conditional jump instructions (JNZ, JNC, JPO, JP, JZ, JC, JPE, JM) a16. These work very similarly to the JMP a16 instruction, but they only jump to a16 if a certain condition is met (ex: JNZ a16 only jumps if cpu’s zero flag is not set). Below is the code for JNZ, JNC, JPO, and JP:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.4.png" alt="code" width="600"></img>
			<br><br>
			The remaining 4 conditional jumps had very similar implementations, they were more or less the same with the flag check condition inverted (ex: JZ checks if the zero flag IS set). I then moved on to SHLD/LHLD a16, which are Store HL Direct and Load HL Direct. These both require 2 ram accesses initially to retrieve a16 from memory. SHLD writes the H register at memory address a16, and the L register at memory address a16+1. LHLD retrieves one byte from memory address a16 to store in the L register, and another byte from address a16+1 to store in the H register. The code I wrote for both of these instructions can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.6.png" alt="code" width="600"></img>
			<br><br>
			Next was LXI rp,d16 which loads two bytes from memory and stores them in a register pair, specified by the opcode. It can also load into the stack pointer, so I wrote a match block to decide where to store the retrieved bytes.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.7.png" alt="code" width="600"></img>
			<br><br>
			Next was MVI reg,d8 which loads one byte of data from memory and stores it in the register specified by the opcode. I was able to really use the framework I set up yesterday to keep the code clean, I also referenced the programmer’s manual to figure out which opcode bits held the register encoding. The reference I used as well as the code I wrote can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.8.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.9.png" alt="code" width="600"></img>
			<br><br>
			I then found two relatively simple instructions, specifically PCHL and SPHL, which set either the PC or SP respectively to the contents of the HL register pair.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.10.png" alt="code" width="600"></img>
			<br><br>
			I then moved on to the 8-bit arithmetic instructions with immediates (ADI d8, ORI d8, etc.). I borrowed a lot of logic from the other 8-bit arithmetic instructions, the key difference is that the other operand had to be retrieved from memory first. The flag logic was exactly the same, I just had to set next_pc to pc+2 to skip over the data byte when fetching the next instruction. The code for all 8 of these instructions can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.11.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.12.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.13.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.14.png" alt="code" width="600"></img>
			<br><br>
			The last two miscellaneous instructions I had to implement were the XTHL and XCHG instructions. XTHL trades the values of the HL register pair and the two bytes at the top of the stack (sp & sp + 1). XCHG swaps the values of the HL and DE register pairs. Finishing these instructions leaves me with the call, return, and reset instructions.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.15.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.16.png" alt="code" width="600"></img>
			<br><br>
			I had to look at the programmer’s manual to figure out how the RST instructions work. After some reading, I learned that bits 5-3 of the opcode are used to define where the PC will be reset to as follows: 0b00000000 00 b5 b4 b3 000. By bitwise ANDing the opcode with 0x38, I am able to get the new PC value easily. The old PC is pushed to the stack, then the PC is set to the new value. The excerpt from the programmer’s manual I read as well as my code is below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.17.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.18.png" alt="code" width="600"></img>
			<br><br>
			The CALL instructions are used to call subroutines. The way they do this is by pushing PC+3 to the stack (it first needs 2 bytes of memory to specify the call address), then setting the PC value to whatever was retrieved from memory. CALL a16 is an unconditional call, the code looks like this:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.19.png" alt="code" width="600"></img>
			<br><br>
			Implementing the conditional calls (CNZ, CNC, etc.) used very similar logic to the conditional jumps, but they use the same structure as CALL a16. Basically if a flag condition is met, it will push PC+3 to the stack and update PC to the value retrieved from memory. Otherwise, it will just set the PC to PC+3 (skipping over data bytes before fetching the next instruction). I implemented all 8 of these conditional calls, here’s CNZ a16 for example:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.20.png" alt="code" width="600"></img>
			<br><br>
			It was at this point that I realized that my life would be a lot easier if I wrote helper functions to push and pop to/from the stack, instead of manually writing it out every time. I just wrapped the code I wrote into these helper functions, then went back through and put them in anytime I was using the stack.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.21.png" alt="code" width="600"></img>
			<br><br>
			The last instructions to implement were the return functions, which are designed for return from subroutines. These are relatively simple, they just pop 2 bytes off the stack and set the PC to that new value. There is an unconditional return (RET) as well as conditional versions (RNZ, RNC, etc.), so I followed the same structure as the call instructions to produce the following code:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.22.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_5.23.png" alt="code" width="600"></img>
			<br><br>
			The only instructions left in the instruction set are IN d8 and OUT d8, which we will not be implementing, so I am now ready to just start testing programs with any instructions I want. Once my teammates are done debugging the read/write transactions on our cards, I can start testing the emulator on our actual hardware, which puts us one step closer to having full CPU-RAM communication
			<br><br><br><br>
	<!--  Week 15, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: April 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started cleaning up the code for cpu.rs a bit so that I can actually read it. I had defined an enum called Reg that maps the register name (A, B, C, M, etc.) to a 3-bit code (0b111, 0b000, etc.), but I never actually used the enum in my code because I couldn’t figure out how to do it. The enum can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.1.png" alt="code" width="600"></img>
			<br><br>
			I figured out that I needed to implement functions to go from Reg to u8 and from u8 to Reg in order to get this to work, so that’s what I did. These functions can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.2.png" alt="code" width="600"></img>
			<br><br>
			After implementing this, I was able to (quite painfully) go through cpu.rs and change anywhere I was explicitly using the binary code for a register, instead using Reg::A, Reg::B, etc. to index into the CPU struct’s registers field. This was mainly in the get/set register functions, but there were also a few places in execute_instruction() where I was doing this. Some of the updated (and more readable) code can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.4.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.6.png" alt="code" width="600"></img>
			<br><br>
			After making these changes, I was still able to get the cpu emulator to build in our rs repository, meaning I can move on to embedded stuff to work towards the PSDR checkoff. 
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.7.png" alt="code" width="600"></img>
			<br><br>
			As soon as I get the emulator itself checked off, I am going to change all of the local RAM requests into tram requests that go over the bus, so I went through the code again and marked all of the places where changes will need to be made with /* TODO: tram requests */. For example:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_4.8.png" alt="code" width="600"></img>
			<br><br>
			Spent some time after that brainstorming about how to tackle the remainder of the project. For getting the PSDR checkoff, I will need only one GPIO pin (clock) to control the execution of the emulator, but other than that it should run without GPIO functionality on the cpu card. This way I can show that the emulator listens to an external clock, executes 8080 instructions, and handles clock cycle timing as specified by our PSDR. 
			<br><br>
			After I get the checkoff, I need to work with Seth to figure out how to integrate memory requests with his PIO bus transactions since he got those working last night. Anywhere I marked the code in cpu.rs, I will need to make a tram request that executes the desired bus transaction, then continues instruction execution. I spent some time reading through his code, but was having difficulty understanding how it works so I’ll need to talk with him a good bit tonight.
			<br><br><br><br>
	<!--  Week 15, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: April 21st </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:45pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 0.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Quickly tried to get the cpu emulator to build inside of the rs repository (embedded context, no_std). The goal is that even after refactoring the code, I am still able to get helpful debugging info on the terminal using the info!() function (want to see CPU state, InstructionInfo, clock cycles, etc.). Since we already have tram and recall building on their own, I tried to mimic the structure of those packages as much as possible. I used the exact same Cargo.toml and folder setup, and I moved main.rs into a bin folder inside of src. This ensures that I can specify the binary file to build with when running cargo run.
			<br><br>
			Since most of the debugging functionality I had implemented was from the std library, I had to change all of those imports to the core version. This involved adding a bunch of use statements in several of the files, such that anything inside of #derive[] or println!() statements came from core instead of std. The added imports can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_3.1.png" alt="code" width="600"></img>
			<br><br>
			This process was mostly just fixing various compiler issues, nothing too interesting to note but it was a fairly tedious process. In order to format the InstructionInfo struct for use with the info!() function, I had to implement the defmt::Format for the struct. The change was simple, just changing #derive[(Debug)] to #derive[(Format)] after adding the necessary imports. The error I got that led me to this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_3.2.png" alt="code" width="600"></img>
			<br><br>
			After fixing the imports/formats I was able to get the package to build inside of the rs repository, which means that I can start testing on the final hardware. As I was reading through the code to refactor it for embedded use, I felt like the code I wrote was kind of hard to follow, so my next step is going to be cleaning up the code a bit, I’ll get to that tomorrow morning as I’m pretty burnt out from today.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_3.3.png" alt="code" width="600"></img>
			<br><br><br><br>
	<!--  Week 15, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: April 21st </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 4:45pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started by looking into the issue of A and L being tied together when updating registers, turns out it was just a simple issue in the fmt::Display function, I accidentally encoded L as 111 instead of 101, resulting in the value at registers[111] being printed for both A and L. Changing the encoding to 101 resolved the issue.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.1.png" alt="code" width="600"></img>
			<br><br>
			Starting where I left off last night, I began implementing LDAX and STAX with the simulated RAM. I had to add a mut ram: RAM parameter to execute_instruction, and update the execute_instruction calls in the main loop accordingly. With those changes, I am able to call ram.read() and ram.write() in execute_instruction() instead of having to go through tram for memory access, which makes testing much simpler for now. The rest of the LDAX/STAX code was more or less just deciding which register pair to use as a memory address, no flags are affected so I didn’t have to worry about that.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.3.png" alt="code" width="600"></img>
			<br><br>
			Went back to update read_m and write_m, realized that it might be better to just add a RAM instance to the CPU struct, as this is closer to the channels communication method I’ll be using later. After doing this, I was able to update read_m() and write_m() as follows:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.4.png" alt="code" width="600"></img>
			<br><br>
			In order to get this new setup to build, I had to modify the CPU::new() function to accept a RAM instance as a parameter, then change anywhere in the code that used ram.read() or ram.write() to self.ram.read() or self.ram.write(). Finally I had to change the structure of the main file to construct the CPU instance such that it contained the RAM instance, but after doing this the workspace builds and works exactly the same as before. When I start integrating this with the rest of the project, any reads/writes will need to be changed to Messages to be passed over the TX/RX channels connected to tram, but the structure is almost exactly the same as our final integration will be.
			<br><br>
			With this new setup, I started implementing PUSH/POP so that I can start using the stack pointer for stuff. For PUSH, the stack pointer must be decremented, the upper byte must be written, the stack pointer is decremented again, then the lower byte is written. For POP, the value at mem address sp is retrieved as the lower byte, the sp is incremented, the byte at new sp is retrieved as upper byte, then the sp is incremented again, and the bytes are concatenated/stored in the appropriate register pair. The code I wrote reflecting this behavior can be seen below, I will test it in the next step:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.6.png" alt="code" width="600"></img>
			<br><br>
			Test case for PUSH/POP: I set a default stack pointer value of 0xFFFF for now, so my plan is to PUSH two values to the stack, do some other instructions, then POP the values off the stack to see if the value is preserved correctly. After thinking about how to write the test case, I realized that it would be a lot easier if LDA a16 was implemented, so I’m gonna take a quick detour to do that. This instruction needs 2 bytes of memory to represent an address, and that address is used to load a value into the accumulator. The code I wrote to accomplish this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.7.png" alt="code" width="600"></img>
			<br><br>
			I wrote a quick test case to verify that LDA works as intended, I initialized memory such that a LDA a16 instruction is followed by the bytes 0xEF and 0xBE, so the address 0xBEEF (which is initialized to 0xFC) will be used to load 0xFC into the accumulator. The test case as well as the correct CPU state after the LDA instruction can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.8.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.9.png" alt="code" width="600"></img>
			<br><br>
			Back to the PUSH/POP instructions test case: similar initialization, but set up 2 values in memory to LDA into the accumulator, then move one into B and one into C. Then PUSH B will put that 16-bit value on the stack, and POP D should pop that value into the D and E registers. The setup I used can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.10.png" alt="code" width="600"></img>
			<br><br>
			The output from the test case looks good, register pair DE holds the value 0xFCA0, which is exactly what we pushed to the stack
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.11.png" alt="code" width="600"></img>
			<br><br>
			Realized that I forgot to set the next_pc to pc + 3 when executing a LDA a16 instruction, so the data bytes were still being fetched and executed as instructions, which is why the flags were wrong initially. After fixing this, the sequence of instructions and resulting flag updates are now correct.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.12.png" alt="code" width="600"></img>
			<br><br>
			Now that PUSH/POP work as intended, I will move on to implementing STA a16, which is similar in structure to LDA a16, but STA a16 stores the accumulator value at the address specified by a16. I’ll write a test case to store the accumulator value at an address, then immediately retrieve it to make sure the value is stored correctly.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.13.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.14.png" alt="code" width="600"></img>
			<br><br>
			After running the test case, the accumulator correctly loads the value that was stored, which can be seen in the output below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_2.15.png" alt="code" width="600"></img>
			<br><br>
			Got through my main goal of finishing LDAX/STAX, POP/PUSH, and LDA/STA a16, gonna take a break and journal this on the website before I move on to transforming this into embedded code. I now have enough instructions done where I can begin writing some more advanced programs and testing functionality, but we desperately need to start getting this running on our final hardware. Still need to figure out how to track clock cycles properly and what bus signals to change when an instruction is done executing. A good starting point would be adding the embassy-sync channels I was using to the current design so that I can start communicating with bus control instead of using a local RAM instance.
			<br><br><br><br>
	<!--  Week 15, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: April 20th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Spent this time continuing to work on execute_instruction(), work consisted of cleaning up old code and starting to implement new instructions. To accomplish this I was mostly referencing the 8080 opcodes table I have been using, as well as the Intel 8080 programmer’s manual, both of which are linked below:
			<br><br>
			<a href="https://www.pastraiser.com/cpu/i8080/i8080_opcodes.html">8080 Opcodes</a>
			<br><br>
			<a href="https://altairclone.com/downloads/manuals/8080%20Programmers%20Manual.pdf">Programmer's Manual</a>
			<br><br>
			I want a way to quickly load/store values to the accumulator register so that I can start testing basic programs, so I started looking into the LDAX/STAX instructions. These instructions use a register pair as a memory address, then either load/store the accumulator value to/from that address in memory. For example, LDAX B takes the address defined by B (pair BC), then loads the value from that address and puts it in the accumulator. STAX D takes the address defined by D (pair DE), then stores the accumulator value at that memory address. The programmer’s manual documentation for these opcodes can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.1.png" alt="code" width="600"></img>
			<br><br>
			After looking into LDAX/STAX, I decided to implement the functionality for the 16-bit registers, which are just the register pairs BC, DE, and HL. I added some quick helper functions for reading/setting a register pair. Reading a register pair concatenates the two required registers and returns the value as a u16, and setting takes a u16 and sets the two corresponding 8-bit registers.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.3.png" alt="code" width="600"></img>
			<br><br>
			As I was scrolling through the execute_instruction() function I am writing, and I did not like the way I was handling MOV instructions, so I decided to clean up the logic a bit. I threw all MOV instructions (including those involving the M register) into a single match statement instead of splitting them up. I added some extra conditional logic in the block to handle the special case where either the src or dst register is M, then called either read_m() or write_m() respectively. read/write_m() still need to be updated with tram functionality, but for now this is fine (just trying to get the PSDR checked off, so no need to involve the bus). The reworked code can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.4.png" alt="code" width="600"></img>
			<br><br>
			I then remembered that I hadn’t finished the flag updating logic for several instructions, including INR/DCR. I had to add an intermediate variable val (value before increment) to help with auxiliary carry logic, but the rest of the flags logic was pretty simple. It was just calling set_szp() and checking if carry/borrow occurred between bits 3 and 4 of the value when incremented.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.6.png" alt="code" width="600"></img>
			<br><br>
			Inside of RAM::init(), I wrote a very basic test case for the MOV instruction. The instructions were INR B, MOV A, B, HLT. In theory after B is incremented, calling MOV A, B should result in a value of 1 being in the A register. When running this, the value was correctly moved into the A register, but the A and L registers both contained the value 0x01, even though the instructions should not be touching the L register at all. I decided to move on to arithmetic instructions to see if this issue would persist with different instructions. The output for the test case can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.7.png" alt="code" width="600"></img>
			<br><br>
			I implemented the ADD instruction, this time making sure to use wrapping_add() as I forgot to do last week. Also updated the flag setting logic appropriately. The code I wrote to do this can be seen below. For all these arithmetic instructions, I am not going to be doing any clock cycle tracking just yet, so I left a blank framework for handling this later (instructions involving M take more clock cycles than others). After writing a quick test case and running it, I noticed that the issue of A and L being tied together persisted but adding worked correctly. The sequence of instructions and output can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.11.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.8.png" alt="code" width="600"></img>
			<br><br>
			Started implementing the rest of the arithmetic operations, starting with ADC. Wrote a special test case where I initialized A to 0xFF, incremented it (which should set the carry flag), then called ADC (first picture). The code for ADC is very similar to ADD, but it also involves adding the current carry flag value to the result (second image). The output for this test case was as I expected, and the flags appear to update properly (third image).
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.12.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.9.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.10.png" alt="code" width="600"></img>
			<br><br>
			Implemented SUB and SBB next, the logic was extremely similar to ADD and ADC, just using wrapping_sub() instead of wrapping_add(). The carry and aux_carry logic was slightly different as these flags indicate borrows instead of carries, but it was still relatively simple.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.13.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.14.png" alt="code" width="600"></img>
			<br><br>
			After looking through the programmer’s manual for how logical operations affect the flags, I learned some interesting details. Sign, zero, and parity can be set as usual using the result of the operation, but aux_carry and carry are handled very differently. The notes I took regarding these instructions are detailed below, as well as my implementations for ANA, XRA, ORA, and CMP. After finishing these instructions, my progress through the instruction set is as follows:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.34.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.15.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.16.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.17.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.18.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.21.png" alt="code" width="600"></img>
			<br><br>
			That completes all of the 8-bit register arithmetic operations, I will need to test those at some point. I started thinking about LDAX/STAX again, as well as LDA/STA a16. Since LDA/STA needs 2 bytes from memory after the opcode (the bytes are located right after the opcode in memory at pc+1 and pc+2), the pc will need to be updated to pc + 3 after completion of the instruction. Similar to stuff I did when I took 437, I created some kind of next_pc logic. It defaults to pc+1, and if an instruction needs to handle pc differently (LDA/STA, JMP, etc.), I will set it explicitly in the corresponding match block. The minor updates I made to the logic can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.19.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.20.png" alt="code" width="600"></img>
			<br><br>
			Started reading up on the POP/PUSH instructions a bit as I want to start adding functionality for the stack pointer. POP/PUSH use bits 5-4 to define the register pair that will be used, and this includes the PSW (concatenation of A and flags). I read the entire section in the programmer’s manual about the details of POP/PUSH, but the main points for our implementation in execute_instruction() can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.22.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.23.png" alt="code" width="600"></img>
			<br><br>
			Since these are going to require tram requests (stack is in memory), I moved on to other register-only instructions, starting with INX/DCX. These are exactly the same as INR/DCR from earlier, just using the register pairs instead of individual registers. INX/DCX can also be used on the stack pointer. These do not affect the flags at all, the code I wrote is pictured below:
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.24.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.25.png" alt="code" width="600"></img>
			<br><br>
			There were some other register-only instructions that I saw while reading through the programmer’s manual. I started by implementing RLC, RAL, RRC, RAR, which rotate (circular shift) the accumulator (or using carry flag to set the new bit after shift). These required some kind of nasty bit manipulation, but they were relatively simple to implement once I understood them.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.26.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.27.png" alt="code" width="600"></img>
			<br><br>
			CMC and CMA were also very simple, as CMC simply inverts the current carry flag, and CMA just performs bitwise AND on the accumulator register.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.28.png" alt="code" width="600"></img>
			<br><br>
			Went back to setting up the framework for POP/PUSH. Similar to what I did for INX/DCX, I set up a match block for identifying the register pair being used. I still need to integrate this with tram for memory access, but in an emergency I can just use simulated RAM to get the PSDR for our CPU emulator alone.
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.29.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.30.png" alt="code" width="600"></img>
			<br><br>
			Wrote some helper functions to simplify the code inside of execute_instructions(), specifically for PSW functionality. I already had a function to pack the flags into a u8, so I wrote a function that takes a u8 and unpacks the flags from that. I also wrote functions for getting/setting the PSW, which were very similar to the other register pair accesses, just calling pack/unpack_flags().
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.31.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.32.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week15/W15_1.33.png" alt="code" width="600"></img>
			<br><br>
			I’m making very good progress on execute_instruction(), and I am getting close to being able to test some basic programs with simulated RAM (which would get us the PSDR). I want to finish LDAX/STAX, POP/PUSH, and LDA/STA a16 before I get testing. After that, I will rework the main function to use the embassy-rp framework, then begin trying to flash it to the micro on our card PCB. This will require a lot of debugging, but once it works we can get the PSDR checked off and begin integrating it with our bus control, front panel, and memory emulator.
			<br><br><br><br>
			<h2>===============   Week 14: =================</h2>
			<!--  Week 14, Entry 5  -->
	<h4><b>Entry 8: -----------------------------------------------------------------</b></h4>
           <b>Date: April 18th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 1:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			While starting to work on implementing functionality for arithmetic instructions inside of execute_instruction(), I realized that I needed to handle the M register much differently than the other registers. After reading through the Wikipedia page about the Intel 8080, I learned that the “M” register is just the value in memory at the address contained in the concatenation of the H and L registers. This means that to access the M register, I need to concatenate the contents of the H and L register into a single u16, then read memory at that address. Using this knowledge, I wrote some skeleton code for getting the address, then reading/writing memory at that address (effectively getting/setting the M register). This code can be seen below, as well as the Wikipedia page that I read through (under the Registers section):
			<br><br>
			<a href="https://en.wikipedia.org/wiki/Intel_8080#Registers">Intel 8080 Wikipedia Page</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_8.1.png" alt="code" width="600"></img>
			<br><br>
			As I figure out timing and making tram requests (in our system, these read/write requests will need to go out on the bus), I will update these read_m() and write_m() functions. The next thing that I did was update read_reg() and set_reg() to include functionality for the M register, which involves calling read_m() and write_m(). The code I wrote can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_8.2.png" alt="code" width="600"></img>
			<br><br>
			I moved on to implementing more instructions in the execute_instruction() function. Starting with the MOV instructions, I wrote the code to move the contents of one register (now including M) to another register. The code is pretty simple for now, but I still need to find a way for MOV instructions that involve M to take 7 cycles, while the others take 5.		
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_8.3.png" alt="code" width="600"></img>
			<br><br>
			I took a quick detour to write the update_szp() function that I mentioned earlier, which uses the new flag setup to set the sign, zero, and parity flags based on the result of an arithmetic calculation. This was pretty simple code, I did have to find the count_ones() function in order to figure out the parity condition, but no issues other than that. This function will be used for any instruction where the sign, zero, and parity flags are affected.
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_8.4.png" alt="code" width="600"></img>
			<br><br>
			After that, I started working on the arithmetic instructions, mainly focusing on the logical operations (ORA, XRA, ANA) since they seemed the simplest to me. I also worked on the add and subtract instructions, but I’m now realizing as I’m writing this that I forgot to use the wrapping_add() and wrapping_sub() functions (I just used +/- operators), so that will definitely need to be fixed. Some of the instruction implementations can be seen below, again I’m not exactly sure how I will handle operations involving M because they will take a different number of clock cycles.	
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_8.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_8.6.png" alt="code" width="600"></img>
			<br><br>
			Assuming I fix some minor issues over the weekend, my progress on the instruction set will be as follows:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_8.7.png" alt="code" width="600"></img>
			<br><br>
			I spent the rest of this session doing some brainstorming about what critical functionality still needs to be implemented to get some basic programs running (eventually on the microcontroller). I thought about it for a while, and here’s the list that I came up with: 1) get flag updates working for every instruction implemented so far: this is critical since some instructions rely on the current state of the flags. 2) update get/set_m to make tram requests, also update fetch_instruction() to make tram request: this is needed for interfacing with our bus. 3) translate the front panel simulation code (keyboard input) into GPIO signals and logic (so that we can start testing with our working front panel card). My goal is to have all 3 of these done early next week so I can start making sure that the integration of the whole system comes together nicely. I should also have enough instructions implemented to start writing some very basic programs and testing that they work as intended.
			<br><br><br><br>
	<!--  Week 14, Entry 7  -->
	<h4><b>Entry 7: -----------------------------------------------------------------</b></h4>
           <b>Date: April 17th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 2:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started my effort to rework how my emulator will handle updating CPU flags. After looking into it a bit (asking ChatGPT), I figured out that when an instruction does not update a given flag, that flag is not reset; it is left as it was from the previous instruction. I started by defining bit masks for each flag. Since affected flags (u8) is a part of the InstructionInfo struct, I figured I could use these bit masks to determine when to update a flag. The bit masks I defined in cpu.rs can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_7.1.png" alt="code" width="600"></img>
			<br><br>
			I also changed the flags in the CPU struct, making them each individual boolean flags instead of them all being stored in a single u8. I did this to make updating them easier (no need to use the individual bit-setting logic I was using), and I scrapped the update_flags() function entirely. My new plan is to have a set_szp() function that sets the sign, zero, and parity flags only (those flags only depend on the result), then handle carry and aux_carry separately (I will code this up later tonight). I still wanted a way to pack the flags into a u8 for pushing/popping a PSW (concatenation of A register and flags, 16 bits total), so I added a pack_flags() function that takes the CPU flags and creates a u8 following the 8080 flags register format (S, Z, 0, A, 0, P, 1, C). I also changed the read functions for each of the flags, they are much simpler now since I just have to immediately return the boolean value from the struct. All of the added/modified code for the flags can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_7.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_7.3.png" alt="code" width="600"></img>
			<br><br>
			The last thing I did was work on execute_instruction() for a bit. I want to get the register arithmetic instructions working as soon as possible, as that will allow me to start testing some programs and check the register values to determine if instructions are being processed properly. I just added a framework for these in the match statement for now, I did this by referencing the 8080 opcodes table and seeing which opcodes correspond to which instructions. The src register is defined in the first 3 bits of each opcode, and all of them use the A register as the other operand, so this should be relatively simple to implement when I have some more time. The link to the opcode table and the framework I set up can be seen below:
			<br><br>
			<a href="https://www.pastraiser.com/cpu/i8080/i8080_opcodes.html">8080 Opcodes Table</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_7.4.png" alt="code" width="600"></img>
			<br><br>
			The execute_instruction() function is slowly coming along, and I feel like the current set up will allow me to progress much quicker. The next major step is to actually implement the arithmetic instructions and start testing them. 
			<br><br><br><br>
	<!--  Week 14, Entry 6  -->
	<h4><b>Entry 6: -----------------------------------------------------------------</b></h4>
           <b>Date: April 16th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on getting execute_instruction() to work for a few instructions. With NOPs and HLT already implemented, I started moving on to some simple instructions, particularly INR and DCR. I will handle updating flags later, but the code for now was extremely simple. The register number to be incremented/decremented is stored in the bits 5-3 of the opcode, so I just read the corresponding register’s value, then either incremented or decremented it using the wrapping_add(1)/wrapping_sub(1) functions. These functions are necessary because otherwise the program would panic on overflow/underflow, and these functions prevent that from happening. For instance, using 8-bit registers, adding 1 to 0xFF will result in the new value being 0x00. The documentation for these functions and test case for INR/DCR B output can be seen below, they are working flawlessly for now but I will need to update them to handle flags later.	
			<br><br>
			<a href="https://doc.rust-lang.org/std/intrinsics/fn.wrapping_add.html">wrapping_add() - Rust</a>
			<br><br>
			<a href="https://doc.rust-lang.org/std/intrinsics/fn.wrapping_sub.html">wrapping_sub() - Rust</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_6.1.png" alt="code" width="600"></img>
			<br><br>
			I then decided to make my first attempt at some kind of flag updating function. As I soon figured out this will not work for all instructions, but it should work for INR/DCR instructions. It takes a parameter result (u8), and sets the CPU flags for zero, sign, and parity according to the result. I had the flags just as a u8 in the CPU struct, so implementing this involved turning on/off the specific bits corresponding to each flag. The code for that can be seen below, as well as how it is used in the INR/DCR section of the execute_instruction() function.
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_6.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_6.3.png" alt="code" width="600"></img>
			<br><br>
			I also wrote a quick format_flags() function that transforms the CPU flags into a string to be used with fmt::Display. After running the same test case, we can see that the flags are updated properly and printed to the terminal. The updated fmt::Display code as well as the output can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_6.4.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_6.5.png" alt="code" width="600"></img>
			<br><br>
			I then quickly implemented functionality for the EI and DI instructions, which enable and disable interrupts for the CPU. Their opcodes are 0xF3 and 0xFB respectively. I did this by adding a boolean flag to the CPU struct called interrupt_enable, and these instructions just toggle it on or off. Here’s the code I wrote for those instructions:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_6.6.png" alt="code" width="600"></img>
			<br><br>
			I tried to make an attempt at implementing some arithmetic instructions, but I soon realized that I would need to handle the flags completely differently for each operation (carry and aux_carry specifically). After brainstorming for a while, I couldn’t come up with anything scalable, so I decided to go to bed and revisit it later. There’s still a lot of work left to do, but I feel like I am making good progress on this CPU emulator. The next steps are fixing the flag handling issue, finishing execute_instruction(), and working on getting the emulator to work with the right number of clock cycles for each instruction. After that I can test functionality without GPIO, then translate all of the simulator-specific functionality into GPIO stuff (button on front panel instead of keyboard input, clk on GPIO pin, etc.). My current progress on working through the instruction set can be seen below, I’ll continue to update this as I make progress.
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_6.7.png" alt="code" width="600"></img>
			<br><br><br><br>
	<!--  Week 14, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: April 16th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			At the beginning of lab section, I updated the formatter for printing InstructionInfo implementing the std::fmt::Display function for InstructionInfo myself instead of relying on #[derive(Debug)] to do it. This way, the flags affected by each instruction can be printed in binary instead of decimal, which is much easier to debug. Since each flag is represented by a single bit in the u8 for flags, printing in binary makes much more sense. We had our meeting with the instructors, where I showed my progress on the CPU instruction decoding simulation for my weekly show-me-a-thing. 
			<br><br>
			I then started reading through the 8080 instruction set to begin working on actually executing some of the instructions. I was mainly referencing the Intel 8080 programming guide, specifically section 2, which defines the instruction set. I noticed that some of the instruction groups (MOV, INR/DCR, arithmetic register operations) follow the same pattern, where certain bits in the opcode define which register(s) are to be used. The link to the programmer manual and some of the instructions I was looking at can be seen below:
			<br><br>
			<a href="https://altairclone.com/downloads/manuals/8080%20Programmers%20Manual.pdf">Intel 8080 Programmer's Manual</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.3.png" alt="code" width="600"></img>
			<br><br>
			After noticing these patterns, I decided to change the way I am handling registers in the CPU struct. Instead of defining each register individually in the struct, it would be easier to define the registers as an array of registers, so that when we decode an instruction where certain bits correspond to a register, I can use those bits of the opcode to index into the registers array. This will reduce the amount of code that I have to write drastically, the updated register implementation can be seen below:	
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.4.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.6.png" alt="code" width="600"></img>
			<br><br>
			After changing that, I started writing some skeleton code for the execute_instruction() function. This function takes an opcode (u8) and returns nothing for now. It decodes the opcode into InstructionInfo using the lookup table I made last night, then checks the opcode to decide what to do. Using match statements and if/else statements, I first checked for NOP and HLT instructions, and HLT sets the halt flag of the CPU to true. After that, I check of we have a MOV instruction by masking/checking the first two bits of the opcode, where 01 indicates a MOV instruction. I haven’t fully implemented it yet, but inside of that if block will be logic for decoding the src and dst registers. After that I added logic for identifying arithmetic operations by masking the first 5 bits of the opcode. The outline I have implemented can be seen below, I need to keep working on it:			
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.7.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.8.png" alt="code" width="600"></img>
			<br><br>
			The last thing I did was call this function in the main loop to clean up the logic a bit, the code for that can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_5.9.png" alt="code" width="600"></img>
			<br><br>
			Once execute_instruction() works properly, I want to set up a basic program in RAM and get this to work on our actual hardware so we can get the corresponding PSDR checked off. Next step: keep working on and debug the execute_instruction() function utilizing the debugging info I set up last night.
			<br><br><br><br>
	<!--  Week 14, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: April 16th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 0.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			On my walk back from lab I realized that I could implement a quick debugging tool to print the CPU’s state at any point in single-step execution. In the simulator, I added some code so that pressing the p key will print the CPU’s current state (registers, pc) to the terminal. The code I added to main for this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_4.1.png" alt="code" width="600"></img>
			<br><br>
			In order to get this to work, I had to implement the fmt::Display for the CPU struct using std::fmt. I’ll link the documentation for std::fmt below, but fmt() returns a fmt::Result that will then be put on std::out (to the terminal). By using a series of writeln!() calls, I was able to make a clean format for printing the CPU’s state. I will keep adding to this as more debugging info is needed (flags, stack pointer, etc.)
			<br><br>
			<a href="https://doc.rust-lang.org/std/fmt/">std::fmt - Rust</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_4.2.png" alt="code" width="600"></img>
			<br><br>
			After running cargo build and cargo run, I was able to press p to print the CPU state, press n a few times to decode some instructions, then press p again to print the state again. The output to the terminal can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_4.3.png" alt="code" width="600"></img>
			<br><br>
			While this will not work in no_std environments for our final design (std::fmt is part of the std library), this will be a great help in debugging instruction execution in the simulation once I start working on that. Since the instructions are not currently being executed, the output is meaningless, but the CPU state will update once instructions are actually being processed.
			<br><br><br><br>
	<!--  Week 14, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: April 15th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I spent this time working on the instruction decoding for our CPU emulator. Since the entire byte of the instruction is just an opcode, decoding involves looking up the opcode and determining if the CPU needs more bytes from memory, how many cycles it will take, and what flags will be modified. I found a good reference for example, so I will need to make a lookup table for all 256 opcodes in the 8080 instruction set following this table:
			<br><br>
			<a href="https://www.pastraiser.com/cpu/i8080/i8080_opcodes.html">8080 Opcode Info Table</a>	
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.1.png" alt="table" width="800"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.2.png" alt="details" width="800"></img>
			<br><br>
			Following this table closely, I made a InstructionInfo struct and table entries for all 256 opcodes that contains the information listed above, the code for this can be seen below (this was a pretty long and tedious process)
			<br><br>
			<img src="Team/journal/img - member3/W14_3.21.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.4.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.6.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.7.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.8.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.9.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.10.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.11.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.12.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.13.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.14.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.15.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.16.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.17.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.18.png" alt="code" width="600"></img>
			<br><br>
			I did realize towards the end that some instructions, specifically some of the conditional instructions, can take a different number of clock cycles depending on whether or not the condition is met, so I will need to figure out how to handle that at some point. 
			<br><br>
			After I finished the lookup table I wanted to test it out using the simulator that I made earlier this week. I first decided to implement a run mode for the simulator, which is triggered by pressing the r key on the keyboard. When run mode is enabled, the cpu will read an instruction from RAM, decode it, then move on to the next instruction until it runs into a HLT instruction, at which point it breaks from the loop. I added the same HLT recognition functionality to single-step mode (pressing the n key). The code for run mode can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.19.png" alt="drawing" width="600"></img>
			<br><br>
			I imported the instruction lookup table into the main file, then loaded RAM with all of the instructions. If run mode works correctly, the simulator should decode instructions until it hits entry 0x76 in RAM, which is a HLT instruction (opcode is 0x76). After running cargo build and cargo run, I got the following output, indicating that run mode and the lookup table were functioning correctly. 
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.20.png" alt="code" width="600"></img>
			<br><br>
			Now that the CPU can decode opcodes into InstructionInfo, the next step is to figure out the actual execution of these instructions. The CPU will need to look at the cycles and bytes fields of the InstructionInfo to figure out what to do, I’ll figure out more refined implementation details here soon. I also want to add more of the front panel functionality to the simulator, including deposit and examine (for manually reading/writing memory). This way the user can input instructions to the simulator, then either run or single step through the program. Fully implementing the front panel on the simulator would allow me to start testing the CPU/memory interface without needing a working bus, which is a good abstraction that will help us test individual parts of the software before putting everything together.
			<br><br><br><br>
	<!--  Week 14, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: April 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<a href="https://github.com/cbiffle/rs80/blob/master/src/emu.rs">rs80 repository</a>
			<br><br>
			<a href="https://www.youtube.com/playlist?list=PLLwK93hM93Z13TRzPx9JqTIn33feefl37">6502 C++ Emulator YouTube Playlist</a>
			<br><br>
			Gonna spend most of this week continuing to work on the CPU emulator (runner package). After finishing the second episode of the 6502 C++ emulator YouTube series and reading the relevant parts of the rs80 repository, I decided to wrap all of the flags that the 8080 processor has into a Flags struct. The YouTube series just had a single 8-bit register to store the flag/status values, but the rs80 has a separate Flags struct and I think that that is gonna be the cleanest way to do it since the aux_carry flag needs to be handled a little bit differently. After looking into what auxiliary carry is, it is specifically for binary-coded decimal (BCD) computations, and the flag lets the processor know to make adjustments under certain circumstances. 
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.1.png" alt="code" width="600"></img>
			<br><br>
			<a href="https://en.wikipedia.org/wiki/Half-carry_flag">Wikipedia - Half-carry-flag</a>	
			<br><br>
			This is an example from the Wikipedia page for the Half-Carry Flag (linked in the Intel 8080 Wikipedia page). Since BCD arithmetic is concerned with groups of 4 bits, if overflow from the lower four bits carries into the upper four bits, the CPU needs to make some adjustments to ensure correct BCD arithmetic, and will thus raise the aux_carry (half-carry) flag. I don’t need to know the specific arithmetic details yet, just need to know when to raise the flag. After understanding this, I wrote the Flags struct, mostly referencing the flags register layout from the Wikipedia page, but I modified some code from the rs80 repository for the aux_carry part because I was unsure of how to implement it. Below is the flags register layout and the code that I wrote to support its functionality. This includes reading/setting flags, as well as packing/unpacking them to/from a Program Status Word (PSW). This is just a combination of the 8-bit A register and 8-bit flags register (16-bit total). This will be used on context-switches and interrupts as a “CPU state” so control flow can be restored.
			<br><br>
			<a href="https://en.wikipedia.org/wiki/Intel_8080#Flags">Wikipedia - Intel 8080 Flags</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.4.png" alt="code" width="600"></img>
			<br><br>
			After this I started thinking about how instructions were going to be executed, and decided that I could write some very simple helper functions to aid with execution. For instance, since the JMP instruction just updates the program counter to a new address, once we detect a JMP instruction, we should just call the jump() function, which will just update the CPU struct’s program_counter member to the new address. During this process I did remember that since program_counter/stack_pointer are gonna be used to access an array (in our memory emulator), I need to change them to usize instead of u16 as I ran into issues with this earlier. I went ahead and updated this as well. 
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.5.png" alt="code" width="600"></img>
			<br><br>
			There will be a lot more of these helper functions, but since our CPU doesn’t have any memory of its own, it needs to go through tram to make bus requests. This means that for helper functions like load() and store(), those will be responsible for making a tram request and awaiting a response which is slightly more complicated than the rs80 repository’s examples. I decided to look into the details about how the CPU knows when to execute a little more deeply. Building off of my understanding from last week, I asked ChatGPT what exactly happens when the single-step button is pressed. I then cross-referenced that with our bus to make sure that it would work, and this is what I understand so far. When the single-step button is pressed, the front panel asserts the RDY signal, indicating that the CPU should begin processing. The CPU fetches an instruction from memory (through tram, using machine cycles), then decodes that instruction and makes more memory requests if needed. Using bus signals asserted by CPU, front panel can tell when CPU is done, at which point front panel lowers RDY, pausing the CPU. A rough sketch of this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.6.jpg" alt="drawing" width="600"></img>
			<br><br>
			I went ahead and coded up some skeleton code for some of this functionality, specifically communication with tram in the main loop. There are still a lot of details to figure out, but I made two boolean flags, namely waiting_for_mem and waiting_for_tram. This setup is tricky because using awaits to recv() in the main loop could cause the loop to stall indefinitely. These flags are only asserted after a message is sent, so that we only await a channel response if there is gonna be one to receive (preventing the stalling issue). An outline for this behavior can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.7.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.8.png" alt="code" width="600"></img>
			<br><br>
			I want to take this idea and test it with the simulator that I wrote on Sunday, I mainly want to see that when runner sends a message to tram, that tram actually gets that message and forwards it to wherever it needs to go (and that the main loop doesn’t stall indefinitely). Next steps are to continue work on getting instructions to run on the CPU emulator, that will likely involve lookup tables of some kind, but I will probably start by not using an external clock (just write unit tests to test individual instructions), then work on detecting instructions from GPIO later this week. As a result of tonight’s work I now have a better idea of how the front panel and CPU interact through certain bus signals, and I have a much better idea of how I am going to implement single-step functionality.
			<br><br><br><br>
	<!--  Week 14, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: April 13th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			After brainstorming about single-step vs run mode last week, I decided to start writing some kind of simulation for single step. This will be some relatively simple rust code that will listen for keyboard inputs, grab a value from an array, and do something based on that value. This is just adding layers of abstraction to what we are actually trying to implement, but I think this will help me understand it better and verify that our design is gonna work. This simulation involves a CPU and RAM struct, but they are not the same ones used in our project. They are much simpler and are purely for testing abstract ideas like single-stepping and updating a program counter to fetch the next instruction. The simplified CPU and RAM structs can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.2.png" alt="code" width="600"></img>
			<br><br>
			For the main loop, I had to ask ChatGPT about how to get keyboard events because that is something that I have no prior experience with, especially in Rust. It pointed me to the crossterm and tokio packages, specifically crossterm::event::KeyEvent and tokio::task::spawn_blocking(). KeyEvent is useful for determining what key was pressed, and spawn_blocking() is good for spawning a blocking thread, meaning that other async tasks can safely run while we are waiting on keyboard input. 
			<br><br>
			<a href="https://docs.rs/crossterm/latest/crossterm/event/struct.KeyEvent.html">crossterm::event::KeyEvent documentation</a>
			<br><br>
			<a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html">tokio::task::spawn_blocking documentation</a>
			<br><br>
			Using the documentation for both of these packages, I went ahead and wrote the main loop. I did run into a slight issue where I could read keyboard inputs, but the loop would not respond until I pressed enter. A quick Google search pointed me to crossterm::terminal::enable_raw_mode(), which I just had to call before the main loop to fix the issue. 
			<br><br>
			<a href="https://docs.rs/crossterm/latest/crossterm/terminal/fn.enable_raw_mode.html">crossterm::terminal::enable_raw_mode documentation</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.4.png" alt="code" width="600"></img>
			<br><br>
			To test this I preloaded the RAM struct with three bytes: 0x10, 0x20, and 0x30. After running cargo build, I pressed the n key (single-step) 3 times, then the q key (quit) once and got the following output, which is entirely correct.
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.5.png" alt="code" width="600"></img>
			<br><br>
			This simulation should be useful in testing single-step for various instructions, but the CPU struct will need to be expanded to have full instruction decoding/executing functionality. Tomorrow I want to work on our actual CPU emulator a bit more and work on figuring out the main loop such that the CPU can execute and communicate with tram at the same time.
			<br><br><br><br>
			<h2>===============   Week 13: =================</h2>
	<!--  Week 13, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: April 9th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			After our meeting with the instructors, I kept working on putting together the pieces of the CPU emulator. I started by writing some function to read out the flags of the CPU, which can be seen below. These are incredibly simple and are just there to give read access to non-public CPU flags. I might also need setter functions for these at some point, I will figure that out later.			
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_3.1.png" alt="code" width="600"></img>
			<br><br>
			I kept watching the second part of the YouTube series for a bit, then I wrote a function to set the interrupt_enable flag of the CPU, which is turned on and off via the EI/DI instructions.	
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_3.2.png" alt="code" width="600"></img>
			<br><br>
			I then started brainstorming about how the CPU is gonna know when to execute instructions. The clock comes from the front panel, so I had to think about how run mode and single-step mode worked. In single-step, the front panel will pulse the clock for the required number of times to complete the current instruction. In run mode, the front panel will run the clock until a HLT instruction is executed, so the CPU will execute instructions and request memory as needed. I was pretty tired so I didn’t end up writing any code for this yet, but getting those ideas down on paper will guide my implementation next week. I have to spend the remainder of this week studying for exams and completing A11, so I probably won’t get a whole lot of time to work again until the weekend.
			<br><br><br><br>
	<!--  Week 13, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: April 8th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I started this session by trying to figure out how to fix the errors I was getting last time when trying to run cargo build. The panic_handler one was easily fixed by making sure every package involved contained defmt, defmt_rtt, and panic_probe, which when included in the main file, act as a panic handler. 
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.1.PNG" alt="code" width="600"></img>
			<br><br>
			The second error was due to the mutexes I selected for the new channels not having Sync implemented, which was required. To fix this I changed the NoopRawMutexes to CriticalSelectionRawMutexes, which do have Sync functionality. I updated this in the common package, as well as in the channel instances themselves, seen below:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.2.png" alt="code" width="600"></img>
			<br><br>
			Here are the links to the documentation I read through to figure this out:
			<br><br>
			<a href="https://docs.embassy.dev/embassy-sync/git/default/blocking_mutex/raw/struct.NoopRawMutex.html">embassy-sync NoopRawMutex</a>
			<br><br>
			<a href="https://docs.embassy.dev/embassy-sync/git/default/blocking_mutex/raw/struct.CriticalSectionRawMutex.html">embassy-sync CriticalSelectionRawMutex</a>
			<br><br>
			After making this change, I was able to get it to build, which means that we can begin testing it here soon. Debugging for this one shouldn’t be too bad since the actual RAM simulation functionality is pretty simple, it's just a matter of making sure it reads the I/O pins correctly.
			<br><br>
			After that I started brainstorming a bit about how we are going to implement our CPU emulator. What makes our emulator different from a normal emulator is that it needs to listen to an external clock signal to determine when instructions are run. The interface between this and tram should be exactly the same as the interface between tram and recall, so I went ahead and set that up first using the common package:			<br><br>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.4.PNG" alt="code" width="600"></img>
			<br><br>
			I was able to get the framework to build by running cargo build, so I started figuring out how CPU emulation worked. I found a couple of really good references that will guide my implementation, including an existing 8080 emulator written in Rust. If I can read through this code and really understand it, I should be able to reference the concepts and modify the implementation for our purposes. There’s also a really good YouTube playlist of someone writing an emulator for the 6502 processor in C++, so I intend to follow the steps in this series to guide my implementation and code structure. Both of these are linked below:
			<br><br>
			<a href="https://github.com/cbiffle/rs80/blob/master/src/emu.rs">rs80 emu.rs</a>
			<br><br>
			<a href="https://www.youtube.com/playlist?list=PLLwK93hM93Z13TRzPx9JqTIn33feefl37">6502 Emulator YouTube Series</a>
			<br><br>
			Here is an overview of the main differences between our implementation and both of the references. Our emulator needs to listen to an external clock to run. It also has no memory of its own, so any memory requests will need to be sent through tram to be put on the bus. My first thought was to break down each instruction into steps, so that on each pulse of clk (GPIO 4), the emulator will run one instruction step. A crude diagram I drew detailing this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.5.jpg" alt="diagram" width="600"></img>
			<br><br>
			I also wrote a line of code in runner’s main function that accomplishes just this functionality, using the async function wait_for_rising_edge() function from embassy-rp. The main loop will wait for a positive edge, then decide what to do from there.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.6.png" alt="diagram" width="600"></img>
			<br><br>
			Following the patterns present in the first episode of the YouTube series, I set up a general CPU  struct with all of the 8080 registers and flags that it needs. I had to look this up on wikipedia, and I also found some good information on all of the instructions in the ISA (number of clock cycles required, opcodes, etc.) that will guide my implementation of the instruction lookup tables down the road.
			<br><br>
			<a href="https://en.wikipedia.org/wiki/Intel_8080#Registers">Wikipedia: 8080 Registers</a>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.7.png" alt="diagram" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.8.png" alt="diagram" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.9.png" alt="diagram" width="600"></img>
			<br><br>
			After writing this code, I was still able to get the runner package to build using cargo build, so I’m ready to start working through the functionality piece by piece (the warnings were just from unused functions).
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.10.png" alt="build" width="600"></img>
			<br><br>
			After looking up what happens to the 8080 on reset, I was able to write the code for the reset() function. The pc is set to zero, and interrupt_enable is set to false (it can only be enabled by an EI instruction after reset). The flags are cleared, and the contents of the registers are undefined, but I set them to 0 for safety:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.11.png" alt="reset" width="600"></img>
			<br><br>
			The last thing I did was add a halt flag to the CPU struct so that we can track when the CPU is halted via a HLT instruction. I wrote a very basic halt() function that just sets the halt flag to true, and this halt flag will be checked in runner’s main loop to see if execution can continue.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.12.png" alt="halt" width="600"></img>
			<br><br>
			To summarize, I made good progress tonight getting recall to build and starting work on our CPU emulator. There’s still a lot of work to do, and that includes making the lookup tables for instructions, figuring out what the main loop will look like, and writing an execute_instruction() function to control instruction execution.
			<br><br><br><br>
	<!--  Week 13, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: April 7th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I spent this time attempting to get recall to build (updated with the interface to tram) as well as cleaning up the code. After running cargo build, I was getting an error that told me that std::sync::mpsc::channel could not be found. This was because, as I should have noticed earlier, features of the std library cannot be used in no_std environments, which we are using. In our dependencies, I saw the embassy-sync package, which happened to provide channels very similar to the ones I was trying to use, documentation for those below:
			<br><br>
			<a href="https://github.com/embassy-rs/embassy/blob/main/embassy-sync/src/channel.rs">embassy-sync channels</a>
			<br><br>
			After reading through the documentation, I redefined the TX and RX in the lib.rs files in each package, using the first Mutex that I found since I was unsure what they actually did, which can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.1.png" alt="code" width="600"></img>
			<br><br>
			I then updated the send_msg() and recv_msg() functions in the tram and recall structs themselves. Since the embassy-sync channel’s send/recv functions are async functions, I updated the send_msg()/recv_msg() functions to be async functions and used .await to get the async functionality of send/recv (seen below)
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.3.png" alt="code" width="600"></img>
			<br><br>
			The final step of reworking this was to define the channels to be used inside of recall’s main.rs file. These channels needed to be defined as static and were created using the Channel::new() function provided by embassy. The code for this can be seen below with updated imports/dependencies.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.4.png" alt="code" width="600"></img>
			<br><br>
			I decided that I didn’t like having an individual lib.rs file in each package that needed updated every time I made a change, so I defined a common package to be used by packages that need it, which contains its own lib.rs file. This way, when I need to change something that is used by all packages, I can just modify this single lib.rs file, which is much easier. I had to update the Cargo.toml file in each package to support this, but that was as simple as adding the line “common = {workspace=true}” under the [dependencies] section. 
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.6.png" alt="code" width="600"></img>
			<br><br>
			I tried to build this before I had to go to class, and I was getting the error messages seen below. I will try and figure this out tomorrow night. As soon as this gets done, I should be able to get recall to build, which means that we can begin testing it soon (which would mean having 1 out of 4 major packages finished). We desperately need to start working on the CPU emulator (runner package), so I will move on to that as soon as recall builds.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.7.png" alt="code" width="600"></img>
			<br><br><br><br>
			<h2>===============   Week 12: =================</h2>
			<b>I was in Pittsburgh, PA for club gymnastics nationals this week, so no work was done</b>
			<h2>===============   Week 11: =================</h2>
	<!--  Week 11, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:15pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 0.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Had a little time to code, so I started making a Bus struct to cleanly wrap all of the needed GPIO pins into something that tram can use. However, I quickly realized that it is not as simple as designating certain pins as inputs, and other pins as outputs. For example, when executing a memory read, the data lines on the bus should be outputs in tram, so data can be send back to the CPU. However, when executing a memory write, the data lines are inputs to tram so recall can write the data to memory. Since this is the case, I just listed all of our bus signals as AnyPins, which is a way to define the type as a GPIO pin without committing to input/output yet. For future reference, I also added comments to each signal which details its corresponding IO pin number.
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_5.1.png" alt="code" width="600"></img>
			<br><br>
			When interfacing two packages in a main file, I will have to declare a Bus struct and assign the variables to GPIO pins. Having this framework means that I am getting closer to completing all of tram’s interfaces, I just need to finish it and figure out how to call PIO routines to get the bus timings we need. 
			<br><br>
			Next week, I plan on looking into how to assign the pins dynamically (change input/output based on need), and I also need to figure out how to block any other packages from modifying the bus while a request is active (waiting on response).
			<br><br><br><br>
	<!--  Week 11, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started looking into how to detect memory requests on the GPIO pins so that tram can translate them into Messages. In tram, I wrote some skeleton code for a detect_memory_request() function, which will return a summary of the bus signals. Once I figure out how to use the embassy-rp framework a bit better, I can monitor the GPIO pins and assign the values to a BusState struct, which is a middle step in translating GPIO to Messages. It contains the values on the address and data lines, as well as boolean flags for each Message type (is the bus state a read request? write request? etc.). I also added some aliases TX and RX for sender and receiver channels for readability and ease of use. 
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.2.png" alt="code" width="600"></img>
			<br><br>
			Inside of recall’s main loop, I call tram.detect_memory_request(), which returns the current bus state. Then I check the boolean flags of the bus state to determine what kind of request is active, if any. If there is a request, the corresponding message is sent over the channel to recall, and recall will respond accordingly. The updated main loop can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.3.png" alt="code" width="600"></img>
			<br><br>
			This should just about complete the recall-tram interface, so I should be able to transfer most of this logic to the other packages. We are getting closer to being able to test all of our software packages together, which is a huge step in our project.
			<br><br>
			Since the tram attached to recall can just poll incoming GPIO pins (for request detection), the next step is to find a clean way to wrap all of the GPIO pins into a struct that detect_memory_request() can check. This is much easier than passing every single GPIO pin individually to the function. Later tonight I’ll try and get something figured out.
			<br><br><br><br>
	<!--  Week 11, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 12:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Worked on coding up the ideas I came up with in lab, trying to keep it clean and scalable so that my teammates can understand it. Referring to the stuff I drew on the whiteboard, I started setting up channels by adding a send and receive channel to both the recall and tram structs, then adding functions to send and receive messages over the channel, using the .send() and .recv() functions of std::sync::mpsc::channel, documentation below:
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send">std::sync::mpsc::channel.send() - Rust</a>
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv">std::sync::mpsc::channel.send() - Rust</a>
			<br><br>
			The updated code for tram and recall with the above functionality can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.2.png" alt="code" width="600"></img>
			<br><br>
			I also made an attempt at connecting the channels together in recall’s main function, and I also wrote some rough code for how recall is going to respond to messages. I’m not exactly sure if this will work but my idea is this: call tram’s.recv_msg() function (returns an Option<Message>), if there is a message, use a match {} block to figure out what the message is, then either call read() or write(). Nowhere near final code, but it can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.3.png" alt="code" width="600"></img>
			<br><br>
			I’m going to keep working on this tomorrow, as soon as it is done I want to move on to getting GPIO stuff working using the embassy-rp framework. I need to look into what GPIO signals can be used to detect memory requests, and how to translate what is on the GPIO pins into a Message to send to recall. Getting this working and tested would be great progress, since I can use the same logic to work on the other two packages (CPU emulator and front panel software)
			<br><br><br><br>
	<!--  Week 11, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: March 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on cleaning up the code from yesterday, then I realized that a lot of the ideas I came up with yesterday could be useful for much more than prototyping. I saw that the channels could be used exclusively for communication between tram and other packages, and that I could do something similar to the BusMessage struct to send over the channels. Formally, tram will listen for bus changes, detect memory requests, and translate the GPIO signals into a message struct to pass to packages. A sketch of this behavior can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_2.1.jpg" alt="whiteboard" width="600"></img>
			<br><br>
			I talked this over with Seth a bit, and we both agreed that this could work. Also had to meet with the instructors so I didn’t get a whole lot of time to modify the code just yet, but I wrote down a bunch of my ideas in our Discord so I can work on it later. I had a meeting to attend so I had to leave lab early, so I’ll revisit the code later today. I thought about what recall needs to know to respond to memory requests, so I came up with a more abstract Message struct to pass between recall and tram. Tram detects memory request on GPIO, then passes a Message over the channel connecting recall and tram, and recall responds to that message. Here’s the message struct and some of the types I will need for now:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_2.2.png" alt="code" width="600"></img>
			<br><br>
			I now understand how all of our code is going to interface, which is a huge step in the right direction and I should be able to get a lot of code done soon. There are still a few details that still need figured out, which include: 1) how can I use PIO to generate proper timings on GPIO pins for read/write cycles?  and 2) how can I block the bus when there is an active request?
			<br><br><br><br>
	<!--  Week 11, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 25th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I started brainstorming on how to simulate the communication between tram and recall (bus control and memory emulator). I started by drawing a crude diagram on the white board for how our software packages will interact, then I started thinking about how to simulate the communication without using any GPIO stuff just to make sure the packages could communicate properly (following our software architecture diagram, seen below)
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.1.JPG" alt="sw architecture" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.2.jpg" alt="sw interface" width="600"></img>
			<br><br>
			After that I just started writing some code to make a rough interface between tram and recall. I thought that instead of using our actual bus, I could just create some structs for requests and responses to pass between packages. This would allow me to test if the packages could communicate properly until I figure out exactly which bus signals correspond to memory requests and responses.
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.3.png" alt="code1" width="600"></img>
			<br><br>
			I also wrote some rough code in the main loop of recall to constantly poll for requests. My first idea was that tram would have some kind of receive() function, which would return a request or response if there was one active, and would return nothing otherwise (using the std::Option<T> feature, documentation below).
			<br><br>
			<a href="https://doc.rust-lang.org/std/option/">std::option - Rust</a>
			<br><br>
			I haven’t figured out exact details at this point, but if recall gets a request through tram, it will then call its read()/write() functions and generate a response to send back to tram. With this setup tram can handle machine cycles (to get the exact timings we need for reads and writes), and recall is completely blind to them (just calls its local read()/write() and responds to tram). The skeleton code I wrote can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.4.png" alt="code2" width="600"></img>
			<br><br>
			For passing these messages between packages, I found something called channels, which allows me to set up tx and rx channels to pass any data type I want (for our purposes, the BusMessage struct from earlier). For example, I have structs that define Tram and Recall, so I can just add a tx and rx member to them, then connect the channels together in the main function to allow bidirectional communication of BusMessages between the two through the channels.
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">std::sync::mpsc::channel - Rust</a>
			<br><br>
			Finally, I created a TramSim struct to simulate tram’s behavior for now without any bus/GPIO stuff. I added the tx/rx channels described above, I’ll figure out how to connect them to recall tomorrow
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.5.png" alt="code3" width="600"></img>
			<br><br>
			To summarize today’s work, I wrote on the whiteboard and coded some Rust to figure out how to prototype the communication interface between tram and recall. With a little more code connecting tram and recall in recall’s main function, I should be able to send an abstract BusRequest to tram, and recall should act accordingly and send a response back to tram. Since our software architecture dictates that tram is the only thing directly interacting with the bus, getting this figured out means that I can transfer similar logic to our CPU emulator and front panel software, and I should be able to get a full simulation of interfaces between all packages done soon (ignoring bus/GPIO stuff for now for simplicity).
			<br><br>
			In terms of next steps, I want to clean up this code a bit and fully complete the logic so I can start testing it. Once I can test this interface and verify that it’s going to work, I will move on to getting the other side of tram (GPIO/bus interface) figured out. This will involve figuring out which bus signals correspond to read/write requests, and eventually figuring out how to use PIO to get the bus timings we are looking for.
			<br><br><br><br>
			<h2>===============   Week 10: =================</h2>
	<!--  Week 10, Entry 4  -->
	<h4><b>Spring Break, no work this week!</b></h4>
			<br><br><br><br>
			<h2>===============   Week 9: =================</h2>
	<!--  Week 9, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: March 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 6:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on getting the Stamp XL boards connected to a breadboard. Had to hot glue everything to a piece of cardboard for now, but I was able to get all of the pins for one board connected using jumper cables. I was busy packing for spring break so I didn't have time to connect the other one yet, but I was thinking I can at least start debugging some tram stuff using only one board and an Analog Discovery 2, just to see if the timings are looking correct. 
			<br>
			<img src="Team/journal/img - member3/week9/W9_4.1.jpg" alt="crude test harness" width="600"></img>
			<br>
			Once I get settled on break, I will begin writing some tram code and try debugging it on the test harness. Getting tram working is a big hurdle in our project, so setting up to test it is a big step in the right direction. With my free time next week, I hope to come back with a working version of tram that can be tested with our other software. 
			<br><br><br><br>
	<!--  Week 9, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: March 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Went into lab for a bit to solder the other board. I used the lab station soldering iron, and things went a lot smoother this time (it took me half the time of the first one). I soldered it a bit differently this time such that every pad I tried to solder was easily accessible, and by tinning the iron more frequently, the end result was a lot cleaner than the first time. After I was done soldering, I did the same electrical continuity test that I did last time, and everything looked good. Some pictures of the soldered board can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.1.jpg" alt="board 2 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.2.jpg" alt="board 2 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.3.jpg" alt="board 2 solder" width="600"></img>
			<br>
			Now that both boards are soldered, I just need to hook them up to a breadboard to complete the test harness, which will allow me to start testing code over break. Assumming I make good progress over break, we should be able to come together as team after break and get our software working in the coming weeks, which is the last major milestone in this project. 
			<br><br><br><br>
	<!--  Week 9, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: March 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, the instructors looked over some of the Rust code I had written for our memory emulator, and they said that the read() and write() functions looked good. I spent the rest of the time researching PIO so that I can start writing tram next week once my test harness is set up. Most of my research was done by reading the PIO section of the RP2350 datasheet, linked below:
			<br>
			<a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">RP2350 Datasheet</a>
			<br>
			The state machine overview, which can be seen below, helped me understand how to use PIO. There are two scratch registers X and Y, and you just write assembly-type instructions in PIO routines to control the I/O. The RP2350B provides 12 of these state machines in total, so I plan to use as many of these as possible for our bus control implementation (tram). The instrucitons that can be used to control these state machines can also be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.1.png" alt="state machine overview" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.3.png" alt="PIO instructions" width="600"></img>
			<br>
			The datasheet also provided a simple example routine to use as guidance, which generates a simple square wave. It accomplishes this by setting a pin as output, then setting the pin high, waiting, setting the pin low, then repeating. The structure is extremely similar to other assembly variants like RISC-V, so it should be easy for me to extend this example to get the timings that we need for tram signals.
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.2.png" alt="PIO instructions" width="600"></img>
			<br>
			To understand how to use these PIO routines to implement tram, I had to talk with Seth to understand how tram interfaces with our other software packages (CPU emulator, RAM emulator, etc.). We went through some general functionality together, then I created my own flowcahrt with pseudocode to describe the communication of CPU/RAM through tram, which can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.4.jpg" alt="pesudocode" width="600"></img>
			<br>
			This reinforced my understanding that I gained last week while working on the software overview in our presentation. Tram will listen to bus signals from the CPU/RAM emulators, then execute machine cycles (different from clock cycles) to send requests and responses as necessary. As a result of this, I feel like I have a good enough understanding to start coding next week once I have my test harness finished. Once tram is at least partially functional, we can start testing it with the other software packages driving it, which is a huge step in bringing our project together.
			<br><br><br><br>
	<!--  Week 9, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 11th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started the process of setting up my test harness to take on spring break with me. The first step was to solder one of the Stamp XL boards to the Stamp Carrier XL, as well as soldering the pin headers and power connector. I had to first learn how to solder by looking it up online and asking my teammates for tips. I then attempted to solder the Stamp XL board, and it was a bit rough since I am just learning to solder. I ended up messing up on the 12-pin connector on the edge of the board, so I had to desolder it which took a lot longer than I would have thought. The solder ended up filling one of the pin holes, and it was extremely painful to remove. Some images of the completed soldering can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_1.1.jpg" alt="board 1 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_1.2.jpg" alt="board 1 solder" width="600"></img>
			<br>
			The 12-pin edge connector was not completely functional as can be seen in the picture, but all of the pins that I need to start testing recall (memory emulator) should be functional. I did a continuity test using the multimeter and moving along the pins to test for good electrical connection. This is a bit of a detour from the main project, but it will set me up nicely to get some good debugging done while I'm away for spring break next week. The next steps are to a) solder the other board, and b) connect both boards to a breadboard to complete the test harness. 
			<br>
			I also started coding a prototype version of our memory emulator (Recall). Instead of communicating with tram, it will just use GPIO pins to simulate tram signals so that I can debug recall-specific funcitonality. I had to look into designating pins as inputs/outputs using the Embassy framework, but it's pretty simple code as of right now. It is currently incomplete, but I plan to keep working on it next week and test it on the test harness I'm working on. Prototyping recall like this will at least help us make sure that it works correctly before connecting it to tram, which will make debugging easier once we do. 
			<br><br><br><br>
			
			<h2>===============   Week 8: =================</h2>
	<!--  Week 8, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 4th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Tonight I worked on the midterm design review presentation, specifically most of the general overview as well as the software section. I did this by using the midterm design review template presentation and modifying the sections to better suit our project. I decided to go into more detail than required on the software since our project is extremely software heavy, and most of our debugging will be in software rather than hardware. In order to do this, I had to do a bit of research about our software structure and how all the packages will interact. Since I had been focused on writing the memory emulator, I had never looked into how tram (our bus control package) interacts with everything. After reading the diagrams and descriptions that Brian wrote, I understood what tram is trying to accomplish. Effectively, it just watches the bus 24/7 and moderates the completion of machine cycles. Machine cycles can be reads/writes to memory, and they take multiple clock cycles to complete. Credit to Brian for these timing diagrams, we are going to use PIO routines and some Rust code to try and get the following timings for reads/writes on our system. 
			<br>
			<img src="Team/journal/img - member3/week9/W8_1.JPG" alt="timing" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W8_2.JPG" alt="timing" width="600"></img>
			<br>
			It took me around 3 hours to write the 17 slides as I had to gather images from our project, look into the specs of all of our components, and write a lot of details on our software packages. This also required around 1 hour of research on our bus control, then I practiced my portion of the presentation once to make sure I was ready. This contributes to project progress by giving the instructors a good detailed overview of our progress thus far, as well as helping me understand how to begin implementing tram. After the presentation, our main focus will be making progress towards having working software, so I will need to research PIO a bit to figure out exactly how we are going to implement tram. With spring break coming up, I ordered my own RP2350 Stamp XL boards that I can set up my own test harness with. This way I can take that on break with me to test/debug software. 
			<br>
			<a href="https://lectronz.com/products/rp2350-stamp-xl">RP235x Stamp XL Board</a>
			<br><br><br><br>
			
			<h2>===============   Week 7: =================</h2>
	<!--  Week 7, Entry 6  -->
	<h4><b>Entry 6: -----------------------------------------------------------------</b></h4>
           <b>Date: February 28th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:15am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Had a brief team meeting this morning, found out that Seth did in fact get embassy-rp working again, and he was able to flash a blinky LED test case to the micro, and the code inside the main loop actually executed. Since I have a good idea of where our software stands after this week, I started working on the software section of the presentation for next week. I did realize that some of the documentation on our website could use some updates, so I started on that by implementing some of the feedback on A3 - Software Overview. As a result I feel somewhat prepared for the presentation next week, and I have a very good overview of our software that I can easily explain to my teammates when we all work on debugging later this semester.
			<br><br><br><br>
	<!--  Week 7, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: February 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on auditing the rp235x-hal code to support functionality of all 47 GPIO pins on the RP2350B QFN80 package. After reading through most of the repository and RP2350B datasheet (~1 hour), I saw a lot of changes that needed to be made to the UART, I2C, and GPIO sections of the code. Copying the existing framework, I added code to allow UART and I2C functionality to all GPIO pins, and I also enable the pins in GPIO/func.rs.
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.png" alt="datasheet excerpt" width="600"></img>
			<br>
			Now that this is done, I can meet with the team tomorrow morning and try and use the updated rp235x-hal package. Hopefully we can get the code to flash to the micro and we can begin debugging our software. This week has felt like a lot of running into issues, but I think we are moving in the right direction. Worst case scenario, if Seth gets embassy-rp working again, we can always have this as a backup if embassy-rp runs into issues down the road (its RP2350 support is relatively new so I wouldn’t be surprised). Some of the changes to the rp235x-hal code I had to make can be seen below:
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.2.png" alt="website update" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.3.png" alt="website update" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.4.png" alt="website update" width="600"></img>
			<br>
			<br><br><br><br>
	<!--  Week 7, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: February 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Went into lab to try and flash the memory emulator package to one of the prototyping boards on our test harness with the new embassy-rp setup. I first had to move all of my code from eceprog to a WSL environment to use the USB connection for flashing. After realizing that WSL still couldn’t use the USB cable, I had to look into mounting the USB device to WSL. This required some PowerShell commands, but I was able to get the WSL environment to flash my code to the micro. 
			<br>
			<img src="Team/journal/img - member3/week7/W7J4.png" alt="website update" width="600"></img>
			<br>
			We did run into a pretty big issue, which was that the code would flash to the micro and everything looked good, except nothing in the main loop would actually execute. Although rp235x-hal didn’t support all the pins we needed, we were able to flash to the micros with it and the code in the main loop would execute. We decided that I am going to try and add functionality for all 47 GPIO pins in rp235x-hal, and Seth is going to try and fix whatever issues we have with embassy-rp. We now have 2 people working on debugging software issues and 2 people finishing up PCB layouts, so we should be able to fix these issues soon and start finalizing our CPU/memory emulators.
			<br><br><br><br>		
	<!--  Week 7, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:15pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			As I suspected, there was a slight issue with the dependencies in Cargo.toml, but I was able to get it resolved by explicitly stating the version of ‘embassy-time-driver’ as 0.2.0. This did take some around 30 minutes to read through documentation specific to embassy-time, and about 20 minutes to resolve the issue in Cargo.toml. 
			<br>
			<a href="https://github.com/embassy-rs/embassy/tree/main/embassy-rp">embassy-rp repository</a>
			<br>
			 I was working on my computer at home, so I wasn’t able to try flashing to the microcontroller. I also had some issues with the code I had written in main.rs, so after reading more embassy documentation the code was able to build. If we just copy this setup to the other Rust packages we’re writing (CPU emulator, bus control), we should be able to get those flashed and tested in the next couple weeks, so we’re making progress towards software verification.
			<br>
			<br>
			<br><br>
	<!--  Week 7, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, we first met with the instructors, who told us that our new functional description was much better, but that our PSDRs could be a little bit more clear. I then spent around 30 minutes talking with the team and making the PSDRs on the team website more understandable. As a result, the website’s front page should be completely done and all details about our project should be very easy for anyone who reads it to understand.
			<br>
			<img src="Team/journal/img - member3/week7/W7J2.JPG" alt="website update" width="600"></img>
			<br>
			After that, we kept reading through the rp235x-hal repository, and recognized that some of the functionality only had support for the QFN60 package of the RP2350, and not the QFN80 package. For example, UART was only configured for GPIO pins 0-29, but pins 30-47 were not set up. Luckily, we found a replacement for this in the embassy-rp repository, which is another open-source HAL for the RP2350, and this one had support built-in for all pins on the QFN80 package. 
			<br>
			<a href="https://github.com/embassy-rs/embassy/tree/main/embassy-rp">embassy-rp repository</a>
			<br>
			The setup process was almost exactly the same as for rp235x-hal, so I just needed to add embassy-rp stuff as dependencies in the Cargo.toml and cargo.config files. Integrating embassy-rp with the emulator was very similar to rp235x-hal, some code from main.rs can be seen below:
			<br>
			<img src="Team/journal/img - member3/week7/W7J1.JPG" alt="website update" width="600"></img>
			<br>
			After trying to build the code towards the end of lab section, I ran into a configuration error that can be seen below. Something was wrong with our dependencies (likely in Cargo.toml), so the project wouldn’t build or flash to the micro. I had to go to class so I couldn’t get this fixed in lab, but it should be an easy fix. In terms of project progress, this was a small step back, but we should be able to get this resolved and have support for the QFN80 package of our RP2350.
			<br>
			<img src="Team/journal/img - member3/week7/W7J3.png" alt="build error" width="600"></img>
			<br><br><br><br>
	<!--  Week 7, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Decided to start working on the microcontroller-specific programming for the memory emulator. I first had to spend about 45 minutes reading through the rp235x-hal repository to understand how to code with the macros and packages for the RP2350. The top-level README in the rp-hal repository was very helpful with getting it setup and providing examples for how to structure my code.
			<br>
			<a href="https://github.com/rp-rs/rp-hal/tree/main/rp235x-hal">rp235x-hal repository</a>
			<br>
			Then, I had to modify the Cargo.toml and cargo.config files in the emulator’s directory so that the code would build. Took a bit to figure out, but I just had to add some stuff under [dependencies] in Cargo.toml to get the code to build. After integrating the rp235x_hal package with main.rs, I was able to get the code to build on my local machine. However, since I was on eceprog on my laptop (which didn’t support communication over the USB cable we’re using to flash), I was unable to get the emulator flashed to our prototyping board.
			<br>
			Doing this is a big step in our project since getting this set up allows us to start flashing code to the microcontrollers, meaning that using our test harness, we can start doing some basic tests with the CPU/memory emulators and the bus controller (called tram in our project), which are their own separate cargo workspaces meaning they can be flashed to different micros independently.
			<br>
			<br><br><br>

			
			<h2>===============   Week 6: =================</h2>				
	<!--  Week 6, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 21st </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 2:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			Started coding the emulator that will run on our memory card. Using Rust, I wrote some code to execute the read/write functions of memory. Using test functions, I am able to read and write to “addresses” in memory, which are really just indexes to a stack allocated array that holds bytes. The read() function takes a 16 bit address as an argument, and returns the byte located at that address (8 bits). The write() function takes an 8 bit value to write and a 16 bit address, and updates the array with the input byte at the index provided (no return value). Since the read and write functions work, the next step is to get the emulator to use bus signals to call read/write so it can actually function as memory for our system.  I didn’t quite get time to figure out what bus signals that the emulator needs to respond to, so I will need to look into the S100 bus a bit more deeply this weekend to figure out which signals need to be asserted by the CPU/memory emulators to handle reads/writes. I found a good resource that describes some of the signals needed for memory operations, I'll read it more thoroughly in the next couple days but a helpful excerpt can be seen below:
			<br>
			<img src="Team/journal/img - member3/week6/Week6J3.JPG" alt="mem flowchart" width="600"></img>
			<br>
 			I will need to figure out which IO pins we are putting MWrite, PWR, SMEMR, and PDBIN on and write my code accordingly. I will also be looking at the IEEE standard to guide my implementation, link below
			<br>
			<a href="http://www.s100computers.com/General%20Images/ieee696spec.pdf">IEEE standard of S100 bus</a>
			<br>
			<br>
			<br><br>
			
	<!--  Week 6, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 20th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 4:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			After realizing that we will need to emulate memory as well instead of using normal memory chips, I started thinking about how to emulate memory. The simplest approach seems to be using another RP2350B chip on a board exactly like the CPU card, but running a memory emulator instead. I read through the rs80 repository (linked in week 5 journal) some more, then made a basic flowchart for the memory emulator operation, seen below. The emulator will need to listen to the bus for read/write signals, then respond accordingly. Unlike the CPU emulator, the memory emulator will have its own clock so that it can constantly listen to bus signals.
			<br>
			<img src="Team/journal/img - member3/week6/Week5J2_memflow.JPG" alt="mem flowchart" width="600"></img>
			<br>
			We probably will be using a basic stack-allocated array to act as memory, but the emulator will need to respond to bus signals to control reads/writes. Keeping the emulator as simple as possible (basically just an array) will hopefully help us with easy debugging. Tomorrow I am going to start coding the emulator a bit, hopefully I can get basic read/write functionality done. Getting the memory emulator done would allow us to start using our test harness to figure out our bus implementation.
			<br><br><br><br>
	<!--  Week 6, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 18th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, we met with the instructors and figured out that our PSDRs were still not up to standard, and that we all have a slightly different idea of how our project is going to function. I spent a good amount of time talking with Seth about how we are going to handle software, and realized that we need an emulator for memory to run on a second card. I really didn’t get much work done during this time, but I feel like talking with the group changed the way I am going to approach the software implementation. Seth explained our test harness, which is two RP2350s hooked up to a breadboard, so we can run one with the CPU emulator and one with the memory emulator, so we can easily debug our emulators/bus. I’ll probably start thinking about the memory emulator implementation soon. The test harness we will be using to debug emulators/bus stuff can be seen below:
			<br>
			<img src="Team/journal/img - member3/week6/Week6J1_harness.jpg" alt="test harness" width="600"></img>
			<br>
			<br><br><br>
			<h2>===============   Week 5: =================</h2>				
	<!--  Week 5, Entry 4 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
          <b>Date: February 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 6:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
		Spent this time researching the S100 bus a bit, and also looked into how programming on the original Altair 8800 works. I did this by reading some of the IEEE standard for the S100 bus and watching some YouTube videos in a playlist called “Altair 8800 Instructional Videos” about how to program on the Altair 8800, which our project is trying to mimic.  I learned how the various switches on the front panel operate, including the examine switch for examining memory locations and the deposit switch for putting values in memory. I also read about the voltage levels on the original S100 bus, which were some pretty exotic levels including +/-16V, 8V, and +/-5V. The modifications we will make for our project include running everything on 3.3V and using DDR4 DIMM connectors in place of the original 100-pin connectors, although we will be not be using all 288 pins that the connectors provide (less than 100 probably for our desired functionality). I'll draw a rough sketch of the backplane PCB so it is clearer in my mind, seen below.
			<br>
			<img src="Team/journal/img - member3/week5/Week5J4.JPG" alt="backplane rough schematic" width="600"></img>
			<br>
		 Since we now have our RP2350 stamp boards, the next step is getting some Rust running on them so we can start emulating CPU/memory/UART for our functionality cards.
			<br>
		<a href="http://www.s100computers.com/General%20Images/ieee696spec.pdf">Link to IEEE standard of S100 bus</a>
			<br>
		<a href="https://www.youtube.com/watch?v=suyiMfzmZKs&list=PLB3mwSROoJ4KLWM8KwK0cD1dhX35wILBj">Link to Altair 8800 tutorials</a>
			<br><br><br><br>
			
	<!--  Week 5, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: February 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		Spent this time working on updating our website since our functional description was severely lacking in detail. To accomplish this, I just worked directly in our GitHub repository (specifically the index.html file) that is synced to our website (screenshot of some of the modifications I made below). I ended up finishing significantly more detailed functional descriptions of all of our major components, and I also revised our PSDRs to include more detail. This gave me, my teammates, and the instructors a better idea of what we are actually trying to accomplish with our project, which will help all of us in the long run.  
			<br>
			<img src="Team/journal/img - member3/week5/Week5J3.JPG" alt="backplane rough schematic" width="600"></img>
			<br>
		Since I don’t think any of us know super specific details about the bus for our project, I plan on doing some research later today on how the S100 bus actually functions and how we need to modify it for our project.
			<br><br><br><br>
	<!--  Week 5, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		During this lab section, we had our weekly meeting with the instructors, who gave us some good feedback on our functional description and PSDRs. In terms of actual work, I was mostly catching up with the team to see where everyone was at and figuring out how things were coming together. We are working on getting some Rust code flashed to the microcontroller as well as prototyping the front panel with LEDs and switches. I spent the rest of the time researching what dependencies and packages we need to use to get an emulator running on the RP2350 micros. After meeting with the team and instructors, we realized that our functional description on the website was severely lacking in detail, so I plan on setting some time aside later this week to overhaul it. 
			<br>
			<br>
			<br><br>		
	<!--  Week 5, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 10th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		Having learned Rust in the last few weeks, I spent more time reading through the rs80 repository that we are using as reference to better understand how to use Rust for CPU emulation. As a result I have a better understanding of the data types we will be using and how they will work together to emulate the Intel 8080 instruction set. I have an exam later this week so I’m not super focused on doing too much work for our project for the first half of this week, but I will be doing a lot more research later this week to figure out how we are going to emulate CPU, RAM, and UART as I’m sure they will be handled slightly differently.
			<br>
		<a href="https://github.com/cbiffle/rs80">Link to reference Rust emulator</a>
			<br>
			<br><br><br>
			
		    <!-- (just copy/paste for Week 3 and going forward  --> 
			
			<h2>===============   Week 4: =================</h2>				
	<!--  Week 4, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 7 </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 4:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
		During this time I finished my portion of A5 and researched the S100 bus a bit more. I did so by writing in Word and reading the Wikipedia article about the S100 bus. It was hard to find some of the more technical details, but as a result I understand the bus we are trying to implement better. In terms of project progress, I feel ready to start prototyping with muliple RP2350s to try and get a crude bus prototype. Next week, we will begin actually prototyping and trying to get multiple components working together, such as CPU emulator and memory.
			<br>
			<br>
			<br><br>
			
	<!--  Week 4, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 7th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		We met in lab to work on A5 and starting to prototype on a breadboard. I spent most of my time writing for A5 on Word, and I talked with my teammates to figure out some details. I made good progress on A5, and I better understand why we chose the RP2350 over other STM or ESP micros. This contributes to project progress by fulfilling a required assignment and helping me understand what we are using each component for. The next step is to finish A5 and start working on prototyping/bus stuff next week.  
			<br>
			<br>
			<br><br>
			
	<!--  Week 4, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 2nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 12:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		I spent a good amount of time reading and understanding the specs of the RP2350B microcontroller, which we will be using for our project. I did so by reading the datasheet online. As a result I have a better understanding of how our MCUs will interface with other components of our project, and I have a better idea of how to approach our S100-inspired bus. This contributes to our progress because we can now start working on the finer details of bus implementation. We should start prototypying once we get our MCUs and get working on our emulator next. 
			<br>
		
			<br>
			<br><br>
			    <h2>===============   Week 3: =================</h2>
 						
	<!--  Week 3, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: January 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<br>
			<br>
			<br><br>
    <h2>===============   Week 2: =================</h2>
 						
	<!--  Week 2, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: January 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            We met in lab and finalized/formalized our PSDRs, and they now include more specific details about the emulator. The emulator should support all instructions for the 8080 CPU and listen to the clock from the front panel, rather than having its own clock. The other PSDR we changed was with regards to the bus and how it should work. I also spent a little more time on Rustlings, nearly completing the training so I can start working on the emulator next week. Next week I will start working on the emulator and figure out how to achieve the desired frequency. The RP2350 is clocked at 150 MHz, but the Altair 8800 had a 2 MHz clock, so I will need to write the emulator such that roughly 75 emulator instructions execute 1 8080 instruction. 
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            During lab section we met with the course staff to discuss project progress and review our PSDRs. After lab, I spent around 1.5 hours starting to learn Rust through Rustlings, an open source tool for learning Rust. As a result, we figured out what we needed to change on our PSDRs, and I also got more comfortable programming in Rust. We now know what exactly our project milestones are, and I am nearly comfortable enough with Rust to start working on our 8080 emulator.
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 20th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            During this hour I did some research about which programming language I should use for the emulator. I researched by reading other developers opinions about Rust, since I have never used it before. After debating between C, C++, and Rust, I decided on using Rust because Rust is fast like C, but it is memory-safe, which will be good for the amount of memory manipulation that emulating requires. Since some of my group already knows Rust, they may be able to help with the emulator if necessary. This contributes to group progress because I can now start writing the emulator for our CPU. The next obvious step is to learn Rust and research CPU emulation.
			<br>
			<br>
			<br><br>
		   
    <h2>===============   Week 1: =================</h2>

	<!--  Week 1, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 17th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            We met as a team and formalized our various project milestones. We did this by listing desired functionality on the white board, then talking about what is necessary to acomplish the functionality. As a result, we were able to figure out more of what this project entails and assign team roles. This contributed to the team's progress by giving us a better idea of what exactly we need to do. Since I was assigned software lead, my next step is to look into writing an emulator for the Intel 8080 CPU, and to start writing it as soon as possible.
			<br>
			<br>
			<br><br>
			
	<!--  Week 1, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 15th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            This was our first lab meeting, so we spent half of the lab section learning about lab resources. The other half of the lab was discussing our project with the TAs and talking about project milestones within our group.
		We mostly just talked about rough milestone ideas without formalizing anything, but we got a rough idea of the various components of our project. This gave us a good foundation to do our own research and figure out exactly what all needed to be done.
		THe next step is to formalize our milestones and assign team roles, so we can start working on the various project components.
			<br>
			<br>
		 <br><br>


		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		JOURNAL ENTRIES ABOVE
		Make your Journal Entries in the template area above and copy/paste going forward


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->


        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
