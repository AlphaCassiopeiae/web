<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		GO DOWN TO THE JOURNAL ENTRIES SECTION BELOW
		(look for more rows of asterisks)


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->


<!--
This is an example weekly progress report document that team members can use to report their individual progress 
of their ECE477 senior design projects. Weekly progress reports are expected to follow the general guidelines
presented in the "Progress Report Policy" document, posted on Brightspace.  

Please create 4 copies of this example, renaming each copy to <PurdueID>.html, where <PurdueID> corresponds to
the Purdue ITAP Career Account ID given by Purdue to each individual team member. If you have any questions,
contact course staff.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<!--Reconfigurable base tag; used to modify the site root location for root-relative links-->
<!--<base href="https://engineering.purdue.edu/ece477/StudentWebTemplate/" />-->
    <base href="https://engineering.purdue.edu/477grp15/" /> <!-- Replace the N with your team number-->

<!--Content-->
<title>ECE477 Course Documents</title>
<meta name="keywords" content="" />
<meta name="description" content="" />
<meta name="author" content="George Hadley">
<meta name = "format-detection" content = "telephone=no" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<!--CSS-->
<link rel="stylesheet" href="css/default.css" type="text/css" media="all" />
<link rel="stylesheet" href="css/responsive.css">
<link rel="stylesheet" href="css/styles.css">
<link rel="stylesheet" href="css/content.css">
<!--[if IE 6]>
<link href="default_ie6.css" rel="stylesheet" type="text/css" />
<![endif]-->

</head>
<body>
<div id="wrapper_site">
    <div id="wrapper_page">
	<!-- Instantiate global site header.-->
	<div id="header"></div>
		<!-- Instantiate site global navigation bar.-->
		<div id="menu"></div>
	
		<!-- Instantiate a page banner image. Page banner images should be 1100x350px and should be located within the local
			img folder located at this directory level. -->
		<div id="banner">
			<img src="Files/img/BannerImgExample.jpg"></img>
		</div>
	
		<!-- Instantiate "tools" needed for a page. Tools are premade functional blocks that can be used to build a page,
			and include things such as a file lister (for listing out homework assignments or tutorials)
		-->
		
		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		JOURNAL ENTRIES BELOW
		Make your Journal Entries in the template area below and copy/past going forward


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->
		
		<div id="content">
            <h2>Project Journal for Caleb Shinkle</h2>
			<h2>===============   Week 14: =================</h2>
	<!--  Week 14, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: April 16th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 0.5 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			On my walk back from lab I realized that I could implement a quick debugging tool to print the CPU’s state at any point in single-step execution. In the simulator, I added some code so that pressing the p key will print the CPU’s current state (registers, pc) to the terminal. The code I added to main for this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_4.1.png" alt="code" width="600"></img>
			<br><br>
			In order to get this to work, I had to implement the fmt::Display for the CPU struct using std::fmt. I’ll link the documentation for std::fmt below, but fmt() returns a fmt::Result that will then be put on std::out (to the terminal). By using a series of writeln!() calls, I was able to make a clean format for printing the CPU’s state. I will keep adding to this as more debugging info is needed (flags, stack pointer, etc.)
			<br><br>
			<a href="https://doc.rust-lang.org/std/fmt/">std::fmt - Rust</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_4.2.png" alt="code" width="600"></img>
			<br><br>
			After running cargo build and cargo run, I was able to press p to print the CPU state, press n a few times to decode some instructions, then press p again to print the state again. The output to the terminal can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_4.3.png" alt="code" width="600"></img>
			<br><br>
			While this will not work in no_std environments for our final design (std::fmt is part of the std library), this will be a great help in debugging instruction execution in the simulation once I start working on that. Since the instructions are not currently being executed, the output is meaningless, but the CPU state will update once instructions are actually being processed.
			<br><br><br><br>
	<!--  Week 14, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: April 15th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I spent this time working on the instruction decoding for our CPU emulator. Since the entire byte of the instruction is just an opcode, decoding involves looking up the opcode and determining if the CPU needs more bytes from memory, how many cycles it will take, and what flags will be modified. I found a good reference for example, so I will need to make a lookup table for all 256 opcodes in the 8080 instruction set following this table:
			<br><br>
			<a href="https://www.pastraiser.com/cpu/i8080/i8080_opcodes.html">8080 Opcode Info Table</a>	
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.1.png" alt="table" width="800"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.2.png" alt="details" width="800"></img>
			<br><br>
			Following this table closely, I made a InstructionInfo struct and table entries for all 256 opcodes that contains the information listed above, the code for this can be seen below (this was a pretty long and tedious process)
			<br><br>
			<img src="Team/journal/img - member3/W14_3.21.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.4.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.6.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.7.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.8.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.9.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.10.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.11.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.12.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.13.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.14.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.15.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.16.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.17.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.18.png" alt="code" width="600"></img>
			<br><br>
			I did realize towards the end that some instructions, specifically some of the conditional instructions, can take a different number of clock cycles depending on whether or not the condition is met, so I will need to figure out how to handle that at some point. 
			<br><br>
			After I finished the lookup table I wanted to test it out using the simulator that I made earlier this week. I first decided to implement a run mode for the simulator, which is triggered by pressing the r key on the keyboard. When run mode is enabled, the cpu will read an instruction from RAM, decode it, then move on to the next instruction until it runs into a HLT instruction, at which point it breaks from the loop. I added the same HLT recognition functionality to single-step mode (pressing the n key). The code for run mode can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.19.png" alt="drawing" width="600"></img>
			<br><br>
			I imported the instruction lookup table into the main file, then loaded RAM with all of the instructions. If run mode works correctly, the simulator should decode instructions until it hits entry 0x76 in RAM, which is a HLT instruction (opcode is 0x76). After running cargo build and cargo run, I got the following output, indicating that run mode and the lookup table were functioning correctly. 
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_3.20.png" alt="code" width="600"></img>
			<br><br>
			Now that the CPU can decode opcodes into InstructionInfo, the next step is to figure out the actual execution of these instructions. The CPU will need to look at the cycles and bytes fields of the InstructionInfo to figure out what to do, I’ll figure out more refined implementation details here soon. I also want to add more of the front panel functionality to the simulator, including deposit and examine (for manually reading/writing memory). This way the user can input instructions to the simulator, then either run or single step through the program. Fully implementing the front panel on the simulator would allow me to start testing the CPU/memory interface without needing a working bus, which is a good abstraction that will help us test individual parts of the software before putting everything together.
			<br><br><br><br>
	<!--  Week 14, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: April 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<a href="https://github.com/cbiffle/rs80/blob/master/src/emu.rs">rs80 repository</a>
			<br><br>
			<a href="https://www.youtube.com/playlist?list=PLLwK93hM93Z13TRzPx9JqTIn33feefl37">6502 C++ Emulator YouTube Playlist</a>
			<br><br>
			Gonna spend most of this week continuing to work on the CPU emulator (runner package). After finishing the second episode of the 6502 C++ emulator YouTube series and reading the relevant parts of the rs80 repository, I decided to wrap all of the flags that the 8080 processor has into a Flags struct. The YouTube series just had a single 8-bit register to store the flag/status values, but the rs80 has a separate Flags struct and I think that that is gonna be the cleanest way to do it since the aux_carry flag needs to be handled a little bit differently. After looking into what auxiliary carry is, it is specifically for binary-coded decimal (BCD) computations, and the flag lets the processor know to make adjustments under certain circumstances. 
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.1.png" alt="code" width="600"></img>
			<br><br>
			<a href="https://en.wikipedia.org/wiki/Half-carry_flag">Wikipedia - Half-carry-flag</a>	
			<br><br>
			This is an example from the Wikipedia page for the Half-Carry Flag (linked in the Intel 8080 Wikipedia page). Since BCD arithmetic is concerned with groups of 4 bits, if overflow from the lower four bits carries into the upper four bits, the CPU needs to make some adjustments to ensure correct BCD arithmetic, and will thus raise the aux_carry (half-carry) flag. I don’t need to know the specific arithmetic details yet, just need to know when to raise the flag. After understanding this, I wrote the Flags struct, mostly referencing the flags register layout from the Wikipedia page, but I modified some code from the rs80 repository for the aux_carry part because I was unsure of how to implement it. Below is the flags register layout and the code that I wrote to support its functionality. This includes reading/setting flags, as well as packing/unpacking them to/from a Program Status Word (PSW). This is just a combination of the 8-bit A register and 8-bit flags register (16-bit total). This will be used on context-switches and interrupts as a “CPU state” so control flow can be restored.
			<br><br>
			<a href="https://en.wikipedia.org/wiki/Intel_8080#Flags">Wikipedia - Intel 8080 Flags</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.4.png" alt="code" width="600"></img>
			<br><br>
			After this I started thinking about how instructions were going to be executed, and decided that I could write some very simple helper functions to aid with execution. For instance, since the JMP instruction just updates the program counter to a new address, once we detect a JMP instruction, we should just call the jump() function, which will just update the CPU struct’s program_counter member to the new address. During this process I did remember that since program_counter/stack_pointer are gonna be used to access an array (in our memory emulator), I need to change them to usize instead of u16 as I ran into issues with this earlier. I went ahead and updated this as well. 
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.5.png" alt="code" width="600"></img>
			<br><br>
			There will be a lot more of these helper functions, but since our CPU doesn’t have any memory of its own, it needs to go through tram to make bus requests. This means that for helper functions like load() and store(), those will be responsible for making a tram request and awaiting a response which is slightly more complicated than the rs80 repository’s examples. I decided to look into the details about how the CPU knows when to execute a little more deeply. Building off of my understanding from last week, I asked ChatGPT what exactly happens when the single-step button is pressed. I then cross-referenced that with our bus to make sure that it would work, and this is what I understand so far. When the single-step button is pressed, the front panel asserts the RDY signal, indicating that the CPU should begin processing. The CPU fetches an instruction from memory (through tram, using machine cycles), then decodes that instruction and makes more memory requests if needed. Using bus signals asserted by CPU, front panel can tell when CPU is done, at which point front panel lowers RDY, pausing the CPU. A rough sketch of this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.6.jpg" alt="drawing" width="600"></img>
			<br><br>
			I went ahead and coded up some skeleton code for some of this functionality, specifically communication with tram in the main loop. There are still a lot of details to figure out, but I made two boolean flags, namely waiting_for_mem and waiting_for_tram. This setup is tricky because using awaits to recv() in the main loop could cause the loop to stall indefinitely. These flags are only asserted after a message is sent, so that we only await a channel response if there is gonna be one to receive (preventing the stalling issue). An outline for this behavior can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.7.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_2.8.png" alt="code" width="600"></img>
			<br><br>
			I want to take this idea and test it with the simulator that I wrote on Sunday, I mainly want to see that when runner sends a message to tram, that tram actually gets that message and forwards it to wherever it needs to go (and that the main loop doesn’t stall indefinitely). Next steps are to continue work on getting instructions to run on the CPU emulator, that will likely involve lookup tables of some kind, but I will probably start by not using an external clock (just write unit tests to test individual instructions), then work on detecting instructions from GPIO later this week. As a result of tonight’s work I now have a better idea of how the front panel and CPU interact through certain bus signals, and I have a much better idea of how I am going to implement single-step functionality.
			<br><br><br><br>
	<!--  Week 14, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: April 13th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			After brainstorming about single-step vs run mode last week, I decided to start writing some kind of simulation for single step. This will be some relatively simple rust code that will listen for keyboard inputs, grab a value from an array, and do something based on that value. This is just adding layers of abstraction to what we are actually trying to implement, but I think this will help me understand it better and verify that our design is gonna work. This simulation involves a CPU and RAM struct, but they are not the same ones used in our project. They are much simpler and are purely for testing abstract ideas like single-stepping and updating a program counter to fetch the next instruction. The simplified CPU and RAM structs can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.2.png" alt="code" width="600"></img>
			<br><br>
			For the main loop, I had to ask ChatGPT about how to get keyboard events because that is something that I have no prior experience with, especially in Rust. It pointed me to the crossterm and tokio packages, specifically crossterm::event::KeyEvent and tokio::task::spawn_blocking(). KeyEvent is useful for determining what key was pressed, and spawn_blocking() is good for spawning a blocking thread, meaning that other async tasks can safely run while we are waiting on keyboard input. 
			<br><br>
			<a href="https://docs.rs/crossterm/latest/crossterm/event/struct.KeyEvent.html">crossterm::event::KeyEvent documentation</a>
			<br><br>
			<a href="https://docs.rs/tokio/latest/tokio/task/fn.spawn_blocking.html">tokio::task::spawn_blocking documentation</a>
			<br><br>
			Using the documentation for both of these packages, I went ahead and wrote the main loop. I did run into a slight issue where I could read keyboard inputs, but the loop would not respond until I pressed enter. A quick Google search pointed me to crossterm::terminal::enable_raw_mode(), which I just had to call before the main loop to fix the issue. 
			<br><br>
			<a href="https://docs.rs/crossterm/latest/crossterm/terminal/fn.enable_raw_mode.html">crossterm::terminal::enable_raw_mode documentation</a>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.4.png" alt="code" width="600"></img>
			<br><br>
			To test this I preloaded the RAM struct with three bytes: 0x10, 0x20, and 0x30. After running cargo build, I pressed the n key (single-step) 3 times, then the q key (quit) once and got the following output, which is entirely correct.
			<br><br>
			<img src="Team/journal/img - member3/week14/W14_1.5.png" alt="code" width="600"></img>
			<br><br>
			This simulation should be useful in testing single-step for various instructions, but the CPU struct will need to be expanded to have full instruction decoding/executing functionality. Tomorrow I want to work on our actual CPU emulator a bit more and work on figuring out the main loop such that the CPU can execute and communicate with tram at the same time.
			<br><br><br><br>
			<h2>===============   Week 13: =================</h2>
	<!--  Week 13, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: April 9th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			After our meeting with the instructors, I kept working on putting together the pieces of the CPU emulator. I started by writing some function to read out the flags of the CPU, which can be seen below. These are incredibly simple and are just there to give read access to non-public CPU flags. I might also need setter functions for these at some point, I will figure that out later.			
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_3.1.png" alt="code" width="600"></img>
			<br><br>
			I kept watching the second part of the YouTube series for a bit, then I wrote a function to set the interrupt_enable flag of the CPU, which is turned on and off via the EI/DI instructions.	
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_3.2.png" alt="code" width="600"></img>
			<br><br>
			I then started brainstorming about how the CPU is gonna know when to execute instructions. The clock comes from the front panel, so I had to think about how run mode and single-step mode worked. In single-step, the front panel will pulse the clock for the required number of times to complete the current instruction. In run mode, the front panel will run the clock until a HLT instruction is executed, so the CPU will execute instructions and request memory as needed. I was pretty tired so I didn’t end up writing any code for this yet, but getting those ideas down on paper will guide my implementation next week. I have to spend the remainder of this week studying for exams and completing A11, so I probably won’t get a whole lot of time to work again until the weekend.
			<br><br><br><br>
	<!--  Week 13, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: April 8th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I started this session by trying to figure out how to fix the errors I was getting last time when trying to run cargo build. The panic_handler one was easily fixed by making sure every package involved contained defmt, defmt_rtt, and panic_probe, which when included in the main file, act as a panic handler. 
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.1.PNG" alt="code" width="600"></img>
			<br><br>
			The second error was due to the mutexes I selected for the new channels not having Sync implemented, which was required. To fix this I changed the NoopRawMutexes to CriticalSelectionRawMutexes, which do have Sync functionality. I updated this in the common package, as well as in the channel instances themselves, seen below:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.2.png" alt="code" width="600"></img>
			<br><br>
			Here are the links to the documentation I read through to figure this out:
			<br><br>
			<a href="https://docs.embassy.dev/embassy-sync/git/default/blocking_mutex/raw/struct.NoopRawMutex.html">embassy-sync NoopRawMutex</a>
			<br><br>
			<a href="https://docs.embassy.dev/embassy-sync/git/default/blocking_mutex/raw/struct.CriticalSectionRawMutex.html">embassy-sync CriticalSelectionRawMutex</a>
			<br><br>
			After making this change, I was able to get it to build, which means that we can begin testing it here soon. Debugging for this one shouldn’t be too bad since the actual RAM simulation functionality is pretty simple, it's just a matter of making sure it reads the I/O pins correctly.
			<br><br>
			After that I started brainstorming a bit about how we are going to implement our CPU emulator. What makes our emulator different from a normal emulator is that it needs to listen to an external clock signal to determine when instructions are run. The interface between this and tram should be exactly the same as the interface between tram and recall, so I went ahead and set that up first using the common package:			<br><br>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.3.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.4.PNG" alt="code" width="600"></img>
			<br><br>
			I was able to get the framework to build by running cargo build, so I started figuring out how CPU emulation worked. I found a couple of really good references that will guide my implementation, including an existing 8080 emulator written in Rust. If I can read through this code and really understand it, I should be able to reference the concepts and modify the implementation for our purposes. There’s also a really good YouTube playlist of someone writing an emulator for the 6502 processor in C++, so I intend to follow the steps in this series to guide my implementation and code structure. Both of these are linked below:
			<br><br>
			<a href="https://github.com/cbiffle/rs80/blob/master/src/emu.rs">rs80 emu.rs</a>
			<br><br>
			<a href="https://www.youtube.com/playlist?list=PLLwK93hM93Z13TRzPx9JqTIn33feefl37">6502 Emulator YouTube Series</a>
			<br><br>
			Here is an overview of the main differences between our implementation and both of the references. Our emulator needs to listen to an external clock to run. It also has no memory of its own, so any memory requests will need to be sent through tram to be put on the bus. My first thought was to break down each instruction into steps, so that on each pulse of clk (GPIO 4), the emulator will run one instruction step. A crude diagram I drew detailing this can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.5.jpg" alt="diagram" width="600"></img>
			<br><br>
			I also wrote a line of code in runner’s main function that accomplishes just this functionality, using the async function wait_for_rising_edge() function from embassy-rp. The main loop will wait for a positive edge, then decide what to do from there.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.6.png" alt="diagram" width="600"></img>
			<br><br>
			Following the patterns present in the first episode of the YouTube series, I set up a general CPU  struct with all of the 8080 registers and flags that it needs. I had to look this up on wikipedia, and I also found some good information on all of the instructions in the ISA (number of clock cycles required, opcodes, etc.) that will guide my implementation of the instruction lookup tables down the road.
			<br><br>
			<a href="https://en.wikipedia.org/wiki/Intel_8080#Registers">Wikipedia: 8080 Registers</a>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.7.png" alt="diagram" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.8.png" alt="diagram" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.9.png" alt="diagram" width="600"></img>
			<br><br>
			After writing this code, I was still able to get the runner package to build using cargo build, so I’m ready to start working through the functionality piece by piece (the warnings were just from unused functions).
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.10.png" alt="build" width="600"></img>
			<br><br>
			After looking up what happens to the 8080 on reset, I was able to write the code for the reset() function. The pc is set to zero, and interrupt_enable is set to false (it can only be enabled by an EI instruction after reset). The flags are cleared, and the contents of the registers are undefined, but I set them to 0 for safety:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.11.png" alt="reset" width="600"></img>
			<br><br>
			The last thing I did was add a halt flag to the CPU struct so that we can track when the CPU is halted via a HLT instruction. I wrote a very basic halt() function that just sets the halt flag to true, and this halt flag will be checked in runner’s main loop to see if execution can continue.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_2.12.png" alt="halt" width="600"></img>
			<br><br>
			To summarize, I made good progress tonight getting recall to build and starting work on our CPU emulator. There’s still a lot of work to do, and that includes making the lookup tables for instructions, figuring out what the main loop will look like, and writing an execute_instruction() function to control instruction execution.
			<br><br><br><br>
	<!--  Week 13, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: April 7th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I spent this time attempting to get recall to build (updated with the interface to tram) as well as cleaning up the code. After running cargo build, I was getting an error that told me that std::sync::mpsc::channel could not be found. This was because, as I should have noticed earlier, features of the std library cannot be used in no_std environments, which we are using. In our dependencies, I saw the embassy-sync package, which happened to provide channels very similar to the ones I was trying to use, documentation for those below:
			<br><br>
			<a href="https://github.com/embassy-rs/embassy/blob/main/embassy-sync/src/channel.rs">embassy-sync channels</a>
			<br><br>
			After reading through the documentation, I redefined the TX and RX in the lib.rs files in each package, using the first Mutex that I found since I was unsure what they actually did, which can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.1.png" alt="code" width="600"></img>
			<br><br>
			I then updated the send_msg() and recv_msg() functions in the tram and recall structs themselves. Since the embassy-sync channel’s send/recv functions are async functions, I updated the send_msg()/recv_msg() functions to be async functions and used .await to get the async functionality of send/recv (seen below)
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.2.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.3.png" alt="code" width="600"></img>
			<br><br>
			The final step of reworking this was to define the channels to be used inside of recall’s main.rs file. These channels needed to be defined as static and were created using the Channel::new() function provided by embassy. The code for this can be seen below with updated imports/dependencies.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.4.png" alt="code" width="600"></img>
			<br><br>
			I decided that I didn’t like having an individual lib.rs file in each package that needed updated every time I made a change, so I defined a common package to be used by packages that need it, which contains its own lib.rs file. This way, when I need to change something that is used by all packages, I can just modify this single lib.rs file, which is much easier. I had to update the Cargo.toml file in each package to support this, but that was as simple as adding the line “common = {workspace=true}” under the [dependencies] section. 
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.5.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.6.png" alt="code" width="600"></img>
			<br><br>
			I tried to build this before I had to go to class, and I was getting the error messages seen below. I will try and figure this out tomorrow night. As soon as this gets done, I should be able to get recall to build, which means that we can begin testing it soon (which would mean having 1 out of 4 major packages finished). We desperately need to start working on the CPU emulator (runner package), so I will move on to that as soon as recall builds.
			<br><br>
			<img src="Team/journal/img - member3/week13/W13_1.7.png" alt="code" width="600"></img>
			<br><br><br><br>
			<h2>===============   Week 12: =================</h2>
			<b>I was in Pittsburgh, PA for club gymnastics nationals this week, so no work was done</b>
			<h2>===============   Week 11: =================</h2>
	<!--  Week 11, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:15pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 0.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Had a little time to code, so I started making a Bus struct to cleanly wrap all of the needed GPIO pins into something that tram can use. However, I quickly realized that it is not as simple as designating certain pins as inputs, and other pins as outputs. For example, when executing a memory read, the data lines on the bus should be outputs in tram, so data can be send back to the CPU. However, when executing a memory write, the data lines are inputs to tram so recall can write the data to memory. Since this is the case, I just listed all of our bus signals as AnyPins, which is a way to define the type as a GPIO pin without committing to input/output yet. For future reference, I also added comments to each signal which details its corresponding IO pin number.
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_5.1.png" alt="code" width="600"></img>
			<br><br>
			When interfacing two packages in a main file, I will have to declare a Bus struct and assign the variables to GPIO pins. Having this framework means that I am getting closer to completing all of tram’s interfaces, I just need to finish it and figure out how to call PIO routines to get the bus timings we need. 
			<br><br>
			Next week, I plan on looking into how to assign the pins dynamically (change input/output based on need), and I also need to figure out how to block any other packages from modifying the bus while a request is active (waiting on response).
			<br><br><br><br>
	<!--  Week 11, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started looking into how to detect memory requests on the GPIO pins so that tram can translate them into Messages. In tram, I wrote some skeleton code for a detect_memory_request() function, which will return a summary of the bus signals. Once I figure out how to use the embassy-rp framework a bit better, I can monitor the GPIO pins and assign the values to a BusState struct, which is a middle step in translating GPIO to Messages. It contains the values on the address and data lines, as well as boolean flags for each Message type (is the bus state a read request? write request? etc.). I also added some aliases TX and RX for sender and receiver channels for readability and ease of use. 
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.2.png" alt="code" width="600"></img>
			<br><br>
			Inside of recall’s main loop, I call tram.detect_memory_request(), which returns the current bus state. Then I check the boolean flags of the bus state to determine what kind of request is active, if any. If there is a request, the corresponding message is sent over the channel to recall, and recall will respond accordingly. The updated main loop can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_4.3.png" alt="code" width="600"></img>
			<br><br>
			This should just about complete the recall-tram interface, so I should be able to transfer most of this logic to the other packages. We are getting closer to being able to test all of our software packages together, which is a huge step in our project.
			<br><br>
			Since the tram attached to recall can just poll incoming GPIO pins (for request detection), the next step is to find a clean way to wrap all of the GPIO pins into a struct that detect_memory_request() can check. This is much easier than passing every single GPIO pin individually to the function. Later tonight I’ll try and get something figured out.
			<br><br><br><br>
	<!--  Week 11, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: March 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 12:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Worked on coding up the ideas I came up with in lab, trying to keep it clean and scalable so that my teammates can understand it. Referring to the stuff I drew on the whiteboard, I started setting up channels by adding a send and receive channel to both the recall and tram structs, then adding functions to send and receive messages over the channel, using the .send() and .recv() functions of std::sync::mpsc::channel, documentation below:
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send">std::sync::mpsc::channel.send() - Rust</a>
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv">std::sync::mpsc::channel.send() - Rust</a>
			<br><br>
			The updated code for tram and recall with the above functionality can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.1.png" alt="code" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.2.png" alt="code" width="600"></img>
			<br><br>
			I also made an attempt at connecting the channels together in recall’s main function, and I also wrote some rough code for how recall is going to respond to messages. I’m not exactly sure if this will work but my idea is this: call tram’s.recv_msg() function (returns an Option<Message>), if there is a message, use a match {} block to figure out what the message is, then either call read() or write(). Nowhere near final code, but it can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_3.3.png" alt="code" width="600"></img>
			<br><br>
			I’m going to keep working on this tomorrow, as soon as it is done I want to move on to getting GPIO stuff working using the embassy-rp framework. I need to look into what GPIO signals can be used to detect memory requests, and how to translate what is on the GPIO pins into a Message to send to recall. Getting this working and tested would be great progress, since I can use the same logic to work on the other two packages (CPU emulator and front panel software)
			<br><br><br><br>
	<!--  Week 11, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: March 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on cleaning up the code from yesterday, then I realized that a lot of the ideas I came up with yesterday could be useful for much more than prototyping. I saw that the channels could be used exclusively for communication between tram and other packages, and that I could do something similar to the BusMessage struct to send over the channels. Formally, tram will listen for bus changes, detect memory requests, and translate the GPIO signals into a message struct to pass to packages. A sketch of this behavior can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_2.1.jpg" alt="whiteboard" width="600"></img>
			<br><br>
			I talked this over with Seth a bit, and we both agreed that this could work. Also had to meet with the instructors so I didn’t get a whole lot of time to modify the code just yet, but I wrote down a bunch of my ideas in our Discord so I can work on it later. I had a meeting to attend so I had to leave lab early, so I’ll revisit the code later today. I thought about what recall needs to know to respond to memory requests, so I came up with a more abstract Message struct to pass between recall and tram. Tram detects memory request on GPIO, then passes a Message over the channel connecting recall and tram, and recall responds to that message. Here’s the message struct and some of the types I will need for now:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_2.2.png" alt="code" width="600"></img>
			<br><br>
			I now understand how all of our code is going to interface, which is a huge step in the right direction and I should be able to get a lot of code done soon. There are still a few details that still need figured out, which include: 1) how can I use PIO to generate proper timings on GPIO pins for read/write cycles?  and 2) how can I block the bus when there is an active request?
			<br><br><br><br>
	<!--  Week 11, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 25th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			I started brainstorming on how to simulate the communication between tram and recall (bus control and memory emulator). I started by drawing a crude diagram on the white board for how our software packages will interact, then I started thinking about how to simulate the communication without using any GPIO stuff just to make sure the packages could communicate properly (following our software architecture diagram, seen below)
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.1.JPG" alt="sw architecture" width="600"></img>
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.2.jpg" alt="sw interface" width="600"></img>
			<br><br>
			After that I just started writing some code to make a rough interface between tram and recall. I thought that instead of using our actual bus, I could just create some structs for requests and responses to pass between packages. This would allow me to test if the packages could communicate properly until I figure out exactly which bus signals correspond to memory requests and responses.
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.3.png" alt="code1" width="600"></img>
			<br><br>
			I also wrote some rough code in the main loop of recall to constantly poll for requests. My first idea was that tram would have some kind of receive() function, which would return a request or response if there was one active, and would return nothing otherwise (using the std::Option<T> feature, documentation below).
			<br><br>
			<a href="https://doc.rust-lang.org/std/option/">std::option - Rust</a>
			<br><br>
			I haven’t figured out exact details at this point, but if recall gets a request through tram, it will then call its read()/write() functions and generate a response to send back to tram. With this setup tram can handle machine cycles (to get the exact timings we need for reads and writes), and recall is completely blind to them (just calls its local read()/write() and responds to tram). The skeleton code I wrote can be seen below:
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.4.png" alt="code2" width="600"></img>
			<br><br>
			For passing these messages between packages, I found something called channels, which allows me to set up tx and rx channels to pass any data type I want (for our purposes, the BusMessage struct from earlier). For example, I have structs that define Tram and Recall, so I can just add a tx and rx member to them, then connect the channels together in the main function to allow bidirectional communication of BusMessages between the two through the channels.
			<br><br>
			<a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">std::sync::mpsc::channel - Rust</a>
			<br><br>
			Finally, I created a TramSim struct to simulate tram’s behavior for now without any bus/GPIO stuff. I added the tx/rx channels described above, I’ll figure out how to connect them to recall tomorrow
			<br><br>
			<img src="Team/journal/img - member3/week11/W11_1.5.png" alt="code3" width="600"></img>
			<br><br>
			To summarize today’s work, I wrote on the whiteboard and coded some Rust to figure out how to prototype the communication interface between tram and recall. With a little more code connecting tram and recall in recall’s main function, I should be able to send an abstract BusRequest to tram, and recall should act accordingly and send a response back to tram. Since our software architecture dictates that tram is the only thing directly interacting with the bus, getting this figured out means that I can transfer similar logic to our CPU emulator and front panel software, and I should be able to get a full simulation of interfaces between all packages done soon (ignoring bus/GPIO stuff for now for simplicity).
			<br><br>
			In terms of next steps, I want to clean up this code a bit and fully complete the logic so I can start testing it. Once I can test this interface and verify that it’s going to work, I will move on to getting the other side of tram (GPIO/bus interface) figured out. This will involve figuring out which bus signals correspond to read/write requests, and eventually figuring out how to use PIO to get the bus timings we are looking for.
			<br><br><br><br>
			<h2>===============   Week 10: =================</h2>
	<!--  Week 10, Entry 4  -->
	<h4><b>Spring Break, no work this week!</b></h4>
			<br><br><br><br>
			<h2>===============   Week 9: =================</h2>
	<!--  Week 9, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: March 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 6:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on getting the Stamp XL boards connected to a breadboard. Had to hot glue everything to a piece of cardboard for now, but I was able to get all of the pins for one board connected using jumper cables. I was busy packing for spring break so I didn't have time to connect the other one yet, but I was thinking I can at least start debugging some tram stuff using only one board and an Analog Discovery 2, just to see if the timings are looking correct. 
			<br>
			<img src="Team/journal/img - member3/week9/W9_4.1.jpg" alt="crude test harness" width="600"></img>
			<br>
			Once I get settled on break, I will begin writing some tram code and try debugging it on the test harness. Getting tram working is a big hurdle in our project, so setting up to test it is a big step in the right direction. With my free time next week, I hope to come back with a working version of tram that can be tested with our other software. 
			<br><br><br><br>
	<!--  Week 9, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: March 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Went into lab for a bit to solder the other board. I used the lab station soldering iron, and things went a lot smoother this time (it took me half the time of the first one). I soldered it a bit differently this time such that every pad I tried to solder was easily accessible, and by tinning the iron more frequently, the end result was a lot cleaner than the first time. After I was done soldering, I did the same electrical continuity test that I did last time, and everything looked good. Some pictures of the soldered board can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.1.jpg" alt="board 2 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.2.jpg" alt="board 2 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_3.3.jpg" alt="board 2 solder" width="600"></img>
			<br>
			Now that both boards are soldered, I just need to hook them up to a breadboard to complete the test harness, which will allow me to start testing code over break. Assumming I make good progress over break, we should be able to come together as team after break and get our software working in the coming weeks, which is the last major milestone in this project. 
			<br><br><br><br>
	<!--  Week 9, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: March 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, the instructors looked over some of the Rust code I had written for our memory emulator, and they said that the read() and write() functions looked good. I spent the rest of the time researching PIO so that I can start writing tram next week once my test harness is set up. Most of my research was done by reading the PIO section of the RP2350 datasheet, linked below:
			<br>
			<a href="https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf">RP2350 Datasheet</a>
			<br>
			The state machine overview, which can be seen below, helped me understand how to use PIO. There are two scratch registers X and Y, and you just write assembly-type instructions in PIO routines to control the I/O. The RP2350B provides 12 of these state machines in total, so I plan to use as many of these as possible for our bus control implementation (tram). The instrucitons that can be used to control these state machines can also be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.1.png" alt="state machine overview" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.3.png" alt="PIO instructions" width="600"></img>
			<br>
			The datasheet also provided a simple example routine to use as guidance, which generates a simple square wave. It accomplishes this by setting a pin as output, then setting the pin high, waiting, setting the pin low, then repeating. The structure is extremely similar to other assembly variants like RISC-V, so it should be easy for me to extend this example to get the timings that we need for tram signals.
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.2.png" alt="PIO instructions" width="600"></img>
			<br>
			To understand how to use these PIO routines to implement tram, I had to talk with Seth to understand how tram interfaces with our other software packages (CPU emulator, RAM emulator, etc.). We went through some general functionality together, then I created my own flowcahrt with pseudocode to describe the communication of CPU/RAM through tram, which can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_2.4.jpg" alt="pesudocode" width="600"></img>
			<br>
			This reinforced my understanding that I gained last week while working on the software overview in our presentation. Tram will listen to bus signals from the CPU/RAM emulators, then execute machine cycles (different from clock cycles) to send requests and responses as necessary. As a result of this, I feel like I have a good enough understanding to start coding next week once I have my test harness finished. Once tram is at least partially functional, we can start testing it with the other software packages driving it, which is a huge step in bringing our project together.
			<br><br><br><br>
	<!--  Week 9, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 11th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started the process of setting up my test harness to take on spring break with me. The first step was to solder one of the Stamp XL boards to the Stamp Carrier XL, as well as soldering the pin headers and power connector. I had to first learn how to solder by looking it up online and asking my teammates for tips. I then attempted to solder the Stamp XL board, and it was a bit rough since I am just learning to solder. I ended up messing up on the 12-pin connector on the edge of the board, so I had to desolder it which took a lot longer than I would have thought. The solder ended up filling one of the pin holes, and it was extremely painful to remove. Some images of the completed soldering can be seen below:
			<br>
			<img src="Team/journal/img - member3/week9/W9_1.1.jpg" alt="board 1 solder" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W9_1.2.jpg" alt="board 1 solder" width="600"></img>
			<br>
			The 12-pin edge connector was not completely functional as can be seen in the picture, but all of the pins that I need to start testing recall (memory emulator) should be functional. I did a continuity test using the multimeter and moving along the pins to test for good electrical connection. This is a bit of a detour from the main project, but it will set me up nicely to get some good debugging done while I'm away for spring break next week. The next steps are to a) solder the other board, and b) connect both boards to a breadboard to complete the test harness. 
			<br>
			I also started coding a prototype version of our memory emulator (Recall). Instead of communicating with tram, it will just use GPIO pins to simulate tram signals so that I can debug recall-specific funcitonality. I had to look into designating pins as inputs/outputs using the Embassy framework, but it's pretty simple code as of right now. It is currently incomplete, but I plan to keep working on it next week and test it on the test harness I'm working on. Prototyping recall like this will at least help us make sure that it works correctly before connecting it to tram, which will make debugging easier once we do. 
			<br><br><br><br>
			
			<h2>===============   Week 8: =================</h2>
	<!--  Week 8, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: March 4th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Tonight I worked on the midterm design review presentation, specifically most of the general overview as well as the software section. I did this by using the midterm design review template presentation and modifying the sections to better suit our project. I decided to go into more detail than required on the software since our project is extremely software heavy, and most of our debugging will be in software rather than hardware. In order to do this, I had to do a bit of research about our software structure and how all the packages will interact. Since I had been focused on writing the memory emulator, I had never looked into how tram (our bus control package) interacts with everything. After reading the diagrams and descriptions that Brian wrote, I understood what tram is trying to accomplish. Effectively, it just watches the bus 24/7 and moderates the completion of machine cycles. Machine cycles can be reads/writes to memory, and they take multiple clock cycles to complete. Credit to Brian for these timing diagrams, we are going to use PIO routines and some Rust code to try and get the following timings for reads/writes on our system. 
			<br>
			<img src="Team/journal/img - member3/week9/W8_1.JPG" alt="timing" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week9/W8_2.JPG" alt="timing" width="600"></img>
			<br>
			It took me around 3 hours to write the 17 slides as I had to gather images from our project, look into the specs of all of our components, and write a lot of details on our software packages. This also required around 1 hour of research on our bus control, then I practiced my portion of the presentation once to make sure I was ready. This contributes to project progress by giving the instructors a good detailed overview of our progress thus far, as well as helping me understand how to begin implementing tram. After the presentation, our main focus will be making progress towards having working software, so I will need to research PIO a bit to figure out exactly how we are going to implement tram. With spring break coming up, I ordered my own RP2350 Stamp XL boards that I can set up my own test harness with. This way I can take that on break with me to test/debug software. 
			<br>
			<a href="https://lectronz.com/products/rp2350-stamp-xl">RP235x Stamp XL Board</a>
			<br><br><br><br>
			
			<h2>===============   Week 7: =================</h2>
	<!--  Week 7, Entry 6  -->
	<h4><b>Entry 6: -----------------------------------------------------------------</b></h4>
           <b>Date: February 28th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:15am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Had a brief team meeting this morning, found out that Seth did in fact get embassy-rp working again, and he was able to flash a blinky LED test case to the micro, and the code inside the main loop actually executed. Since I have a good idea of where our software stands after this week, I started working on the software section of the presentation for next week. I did realize that some of the documentation on our website could use some updates, so I started on that by implementing some of the feedback on A3 - Software Overview. As a result I feel somewhat prepared for the presentation next week, and I have a very good overview of our software that I can easily explain to my teammates when we all work on debugging later this semester.
			<br><br><br><br>
	<!--  Week 7, Entry 5  -->
	<h4><b>Entry 5: -----------------------------------------------------------------</b></h4>
           <b>Date: February 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 7:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.25 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Started working on auditing the rp235x-hal code to support functionality of all 47 GPIO pins on the RP2350B QFN80 package. After reading through most of the repository and RP2350B datasheet (~1 hour), I saw a lot of changes that needed to be made to the UART, I2C, and GPIO sections of the code. Copying the existing framework, I added code to allow UART and I2C functionality to all GPIO pins, and I also enable the pins in GPIO/func.rs.
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.png" alt="datasheet excerpt" width="600"></img>
			<br>
			Now that this is done, I can meet with the team tomorrow morning and try and use the updated rp235x-hal package. Hopefully we can get the code to flash to the micro and we can begin debugging our software. This week has felt like a lot of running into issues, but I think we are moving in the right direction. Worst case scenario, if Seth gets embassy-rp working again, we can always have this as a backup if embassy-rp runs into issues down the road (its RP2350 support is relatively new so I wouldn’t be surprised). Some of the changes to the rp235x-hal code I had to make can be seen below:
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.2.png" alt="website update" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.3.png" alt="website update" width="600"></img>
			<br>
			<img src="Team/journal/img - member3/week7/W7J6.4.png" alt="website update" width="600"></img>
			<br>
			<br><br><br><br>
	<!--  Week 7, Entry 4  -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
           <b>Date: February 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Went into lab to try and flash the memory emulator package to one of the prototyping boards on our test harness with the new embassy-rp setup. I first had to move all of my code from eceprog to a WSL environment to use the USB connection for flashing. After realizing that WSL still couldn’t use the USB cable, I had to look into mounting the USB device to WSL. This required some PowerShell commands, but I was able to get the WSL environment to flash my code to the micro. 
			<br>
			<img src="Team/journal/img - member3/week7/W7J4.png" alt="website update" width="600"></img>
			<br>
			We did run into a pretty big issue, which was that the code would flash to the micro and everything looked good, except nothing in the main loop would actually execute. Although rp235x-hal didn’t support all the pins we needed, we were able to flash to the micros with it and the code in the main loop would execute. We decided that I am going to try and add functionality for all 47 GPIO pins in rp235x-hal, and Seth is going to try and fix whatever issues we have with embassy-rp. We now have 2 people working on debugging software issues and 2 people finishing up PCB layouts, so we should be able to fix these issues soon and start finalizing our CPU/memory emulators.
			<br><br><br><br>		
	<!--  Week 7, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 11:15pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			As I suspected, there was a slight issue with the dependencies in Cargo.toml, but I was able to get it resolved by explicitly stating the version of ‘embassy-time-driver’ as 0.2.0. This did take some around 30 minutes to read through documentation specific to embassy-time, and about 20 minutes to resolve the issue in Cargo.toml. 
			<br>
			<a href="https://github.com/embassy-rs/embassy/tree/main/embassy-rp">embassy-rp repository</a>
			<br>
			 I was working on my computer at home, so I wasn’t able to try flashing to the microcontroller. I also had some issues with the code I had written in main.rs, so after reading more embassy documentation the code was able to build. If we just copy this setup to the other Rust packages we’re writing (CPU emulator, bus control), we should be able to get those flashed and tested in the next couple weeks, so we’re making progress towards software verification.
			<br>
			<br>
			<br><br>
	<!--  Week 7, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 26th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, we first met with the instructors, who told us that our new functional description was much better, but that our PSDRs could be a little bit more clear. I then spent around 30 minutes talking with the team and making the PSDRs on the team website more understandable. As a result, the website’s front page should be completely done and all details about our project should be very easy for anyone who reads it to understand.
			<br>
			<img src="Team/journal/img - member3/week7/W7J2.JPG" alt="website update" width="600"></img>
			<br>
			After that, we kept reading through the rp235x-hal repository, and recognized that some of the functionality only had support for the QFN60 package of the RP2350, and not the QFN80 package. For example, UART was only configured for GPIO pins 0-29, but pins 30-47 were not set up. Luckily, we found a replacement for this in the embassy-rp repository, which is another open-source HAL for the RP2350, and this one had support built-in for all pins on the QFN80 package. 
			<br>
			<a href="https://github.com/embassy-rs/embassy/tree/main/embassy-rp">embassy-rp repository</a>
			<br>
			The setup process was almost exactly the same as for rp235x-hal, so I just needed to add embassy-rp stuff as dependencies in the Cargo.toml and cargo.config files. Integrating embassy-rp with the emulator was very similar to rp235x-hal, some code from main.rs can be seen below:
			<br>
			<img src="Team/journal/img - member3/week7/W7J1.JPG" alt="website update" width="600"></img>
			<br>
			After trying to build the code towards the end of lab section, I ran into a configuration error that can be seen below. Something was wrong with our dependencies (likely in Cargo.toml), so the project wouldn’t build or flash to the micro. I had to go to class so I couldn’t get this fixed in lab, but it should be an easy fix. In terms of project progress, this was a small step back, but we should be able to get this resolved and have support for the QFN80 package of our RP2350.
			<br>
			<img src="Team/journal/img - member3/week7/W7J3.png" alt="build error" width="600"></img>
			<br><br><br><br>
	<!--  Week 7, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.75 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			Decided to start working on the microcontroller-specific programming for the memory emulator. I first had to spend about 45 minutes reading through the rp235x-hal repository to understand how to code with the macros and packages for the RP2350. The top-level README in the rp-hal repository was very helpful with getting it setup and providing examples for how to structure my code.
			<br>
			<a href="https://github.com/rp-rs/rp-hal/tree/main/rp235x-hal">rp235x-hal repository</a>
			<br>
			Then, I had to modify the Cargo.toml and cargo.config files in the emulator’s directory so that the code would build. Took a bit to figure out, but I just had to add some stuff under [dependencies] in Cargo.toml to get the code to build. After integrating the rp235x_hal package with main.rs, I was able to get the code to build on my local machine. However, since I was on eceprog on my laptop (which didn’t support communication over the USB cable we’re using to flash), I was unable to get the emulator flashed to our prototyping board.
			<br>
			Doing this is a big step in our project since getting this set up allows us to start flashing code to the microcontrollers, meaning that using our test harness, we can start doing some basic tests with the CPU/memory emulators and the bus controller (called tram in our project), which are their own separate cargo workspaces meaning they can be flashed to different micros independently.
			<br>
			<br><br><br>

			
			<h2>===============   Week 6: =================</h2>				
	<!--  Week 6, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 21st </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 2:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			Started coding the emulator that will run on our memory card. Using Rust, I wrote some code to execute the read/write functions of memory. Using test functions, I am able to read and write to “addresses” in memory, which are really just indexes to a stack allocated array that holds bytes. The read() function takes a 16 bit address as an argument, and returns the byte located at that address (8 bits). The write() function takes an 8 bit value to write and a 16 bit address, and updates the array with the input byte at the index provided (no return value). Since the read and write functions work, the next step is to get the emulator to use bus signals to call read/write so it can actually function as memory for our system.  I didn’t quite get time to figure out what bus signals that the emulator needs to respond to, so I will need to look into the S100 bus a bit more deeply this weekend to figure out which signals need to be asserted by the CPU/memory emulators to handle reads/writes. I found a good resource that describes some of the signals needed for memory operations, I'll read it more thoroughly in the next couple days but a helpful excerpt can be seen below:
			<br>
			<img src="Team/journal/img - member3/week6/Week6J3.JPG" alt="mem flowchart" width="600"></img>
			<br>
 			I will need to figure out which IO pins we are putting MWrite, PWR, SMEMR, and PDBIN on and write my code accordingly. I will also be looking at the IEEE standard to guide my implementation, link below
			<br>
			<a href="http://www.s100computers.com/General%20Images/ieee696spec.pdf">IEEE standard of S100 bus</a>
			<br>
			<br>
			<br><br>
			
	<!--  Week 6, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 20th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 4:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			After realizing that we will need to emulate memory as well instead of using normal memory chips, I started thinking about how to emulate memory. The simplest approach seems to be using another RP2350B chip on a board exactly like the CPU card, but running a memory emulator instead. I read through the rs80 repository (linked in week 5 journal) some more, then made a basic flowchart for the memory emulator operation, seen below. The emulator will need to listen to the bus for read/write signals, then respond accordingly. Unlike the CPU emulator, the memory emulator will have its own clock so that it can constantly listen to bus signals.
			<br>
			<img src="Team/journal/img - member3/week6/Week5J2_memflow.JPG" alt="mem flowchart" width="600"></img>
			<br>
			We probably will be using a basic stack-allocated array to act as memory, but the emulator will need to respond to bus signals to control reads/writes. Keeping the emulator as simple as possible (basically just an array) will hopefully help us with easy debugging. Tomorrow I am going to start coding the emulator a bit, hopefully I can get basic read/write functionality done. Getting the memory emulator done would allow us to start using our test harness to figure out our bus implementation.
			<br><br><br><br>
	<!--  Week 6, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 18th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			During this lab section, we met with the instructors and figured out that our PSDRs were still not up to standard, and that we all have a slightly different idea of how our project is going to function. I spent a good amount of time talking with Seth about how we are going to handle software, and realized that we need an emulator for memory to run on a second card. I really didn’t get much work done during this time, but I feel like talking with the group changed the way I am going to approach the software implementation. Seth explained our test harness, which is two RP2350s hooked up to a breadboard, so we can run one with the CPU emulator and one with the memory emulator, so we can easily debug our emulators/bus. I’ll probably start thinking about the memory emulator implementation soon. The test harness we will be using to debug emulators/bus stuff can be seen below:
			<br>
			<img src="Team/journal/img - member3/week6/Week6J1_harness.jpg" alt="test harness" width="600"></img>
			<br>
			<br><br><br>
			<h2>===============   Week 5: =================</h2>				
	<!--  Week 5, Entry 4 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 4: -----------------------------------------------------------------</b></h4>
          <b>Date: February 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 6:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
		Spent this time researching the S100 bus a bit, and also looked into how programming on the original Altair 8800 works. I did this by reading some of the IEEE standard for the S100 bus and watching some YouTube videos in a playlist called “Altair 8800 Instructional Videos” about how to program on the Altair 8800, which our project is trying to mimic.  I learned how the various switches on the front panel operate, including the examine switch for examining memory locations and the deposit switch for putting values in memory. I also read about the voltage levels on the original S100 bus, which were some pretty exotic levels including +/-16V, 8V, and +/-5V. The modifications we will make for our project include running everything on 3.3V and using DDR4 DIMM connectors in place of the original 100-pin connectors, although we will be not be using all 288 pins that the connectors provide (less than 100 probably for our desired functionality). I'll draw a rough sketch of the backplane PCB so it is clearer in my mind, seen below.
			<br>
			<img src="Team/journal/img - member3/week5/Week5J4.JPG" alt="backplane rough schematic" width="600"></img>
			<br>
		 Since we now have our RP2350 stamp boards, the next step is getting some Rust running on them so we can start emulating CPU/memory/UART for our functionality cards.
			<br>
		<a href="http://www.s100computers.com/General%20Images/ieee696spec.pdf">Link to IEEE standard of S100 bus</a>
			<br>
		<a href="https://www.youtube.com/watch?v=suyiMfzmZKs&list=PLB3mwSROoJ4KLWM8KwK0cD1dhX35wILBj">Link to Altair 8800 tutorials</a>
			<br><br><br><br>
			
	<!--  Week 5, Entry 3  -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
           <b>Date: February 14th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		Spent this time working on updating our website since our functional description was severely lacking in detail. To accomplish this, I just worked directly in our GitHub repository (specifically the index.html file) that is synced to our website (screenshot of some of the modifications I made below). I ended up finishing significantly more detailed functional descriptions of all of our major components, and I also revised our PSDRs to include more detail. This gave me, my teammates, and the instructors a better idea of what we are actually trying to accomplish with our project, which will help all of us in the long run.  
			<br>
			<img src="Team/journal/img - member3/week5/Week5J3.JPG" alt="backplane rough schematic" width="600"></img>
			<br>
		Since I don’t think any of us know super specific details about the bus for our project, I plan on doing some research later today on how the S100 bus actually functions and how we need to modify it for our project.
			<br><br><br><br>
	<!--  Week 5, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 12th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		During this lab section, we had our weekly meeting with the instructors, who gave us some good feedback on our functional description and PSDRs. In terms of actual work, I was mostly catching up with the team to see where everyone was at and figuring out how things were coming together. We are working on getting some Rust code flashed to the microcontroller as well as prototyping the front panel with LEDs and switches. I spent the rest of the time researching what dependencies and packages we need to use to get an emulator running on the RP2350 micros. After meeting with the team and instructors, we realized that our functional description on the website was severely lacking in detail, so I plan on setting some time aside later this week to overhaul it. 
			<br>
			<br>
			<br><br>		
	<!--  Week 5, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 10th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		Having learned Rust in the last few weeks, I spent more time reading through the rs80 repository that we are using as reference to better understand how to use Rust for CPU emulation. As a result I have a better understanding of the data types we will be using and how they will work together to emulate the Intel 8080 instruction set. I have an exam later this week so I’m not super focused on doing too much work for our project for the first half of this week, but I will be doing a lot more research later this week to figure out how we are going to emulate CPU, RAM, and UART as I’m sure they will be handled slightly differently.
			<br>
		<a href="https://github.com/cbiffle/rs80">Link to reference Rust emulator</a>
			<br>
			<br><br><br>
			
		    <!-- (just copy/paste for Week 3 and going forward  --> 
			
			<h2>===============   Week 4: =================</h2>				
	<!--  Week 4, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: February 7 </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 4:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
		During this time I finished my portion of A5 and researched the S100 bus a bit more. I did so by writing in Word and reading the Wikipedia article about the S100 bus. It was hard to find some of the more technical details, but as a result I understand the bus we are trying to implement better. In terms of project progress, I feel ready to start prototyping with muliple RP2350s to try and get a crude bus prototype. Next week, we will begin actually prototyping and trying to get multiple components working together, such as CPU emulator and memory.
			<br>
			<br>
			<br><br>
			
	<!--  Week 4, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: February 7th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		We met in lab to work on A5 and starting to prototype on a breadboard. I spent most of my time writing for A5 on Word, and I talked with my teammates to figure out some details. I made good progress on A5, and I better understand why we chose the RP2350 over other STM or ESP micros. This contributes to project progress by fulfilling a required assignment and helping me understand what we are using each component for. The next step is to finish A5 and start working on prototyping/bus stuff next week.  
			<br>
			<br>
			<br><br>
			
	<!--  Week 4, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: February 2nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 12:00pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 3 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
		I spent a good amount of time reading and understanding the specs of the RP2350B microcontroller, which we will be using for our project. I did so by reading the datasheet online. As a result I have a better understanding of how our MCUs will interface with other components of our project, and I have a better idea of how to approach our S100-inspired bus. This contributes to our progress because we can now start working on the finer details of bus implementation. We should start prototypying once we get our MCUs and get working on our emulator next. 
			<br>
		
			<br>
			<br><br>
			    <h2>===============   Week 3: =================</h2>
 						
	<!--  Week 3, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: January 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 10:00am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour--> 
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 27th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
			<br>
			<br>
			<br><br>
    <h2>===============   Week 2: =================</h2>
 						
	<!--  Week 2, Entry 3 (just copy/paste this entry section template for the many more enties this week) -->
	<h4><b>Entry 3: -----------------------------------------------------------------</b></h4>
          <b>Date: January 24th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            We met in lab and finalized/formalized our PSDRs, and they now include more specific details about the emulator. The emulator should support all instructions for the 8080 CPU and listen to the clock from the front panel, rather than having its own clock. The other PSDR we changed was with regards to the bus and how it should work. I also spent a little more time on Rustlings, nearly completing the training so I can start working on the emulator next week. Next week I will start working on the emulator and figure out how to achieve the desired frequency. The RP2350 is clocked at 150 MHz, but the Altair 8800 had a 2 MHz clock, so I will need to write the emulator such that roughly 75 emulator instructions execute 1 8080 instruction. 
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 22nd </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 4 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            During lab section we met with the course staff to discuss project progress and review our PSDRs. After lab, I spent around 1.5 hours starting to learn Rust through Rustlings, an open source tool for learning Rust. As a result, we figured out what we needed to change on our PSDRs, and I also got more comfortable programming in Rust. We now know what exactly our project milestones are, and I am nearly comfortable enough with Rust to start working on our 8080 emulator.
			<br>
			<br>
			<br><br>
			
	<!--  Week 2, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 20th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 3:30pm </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1 hour </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            During this hour I did some research about which programming language I should use for the emulator. I researched by reading other developers opinions about Rust, since I have never used it before. After debating between C, C++, and Rust, I decided on using Rust because Rust is fast like C, but it is memory-safe, which will be good for the amount of memory manipulation that emulating requires. Since some of my group already knows Rust, they may be able to help with the emulator if necessary. This contributes to group progress because I can now start writing the emulator for our CPU. The next obvious step is to learn Rust and research CPU emulation.
			<br>
			<br>
			<br><br>
		   
    <h2>===============   Week 1: =================</h2>

	<!--  Week 1, Entry 2  -->
	<h4><b>Entry 2: -----------------------------------------------------------------</b></h4>
           <b>Date: January 17th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 1.5 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            We met as a team and formalized our various project milestones. We did this by listing desired functionality on the white board, then talking about what is necessary to acomplish the functionality. As a result, we were able to figure out more of what this project entails and assign team roles. This contributed to the team's progress by giving us a better idea of what exactly we need to do. Since I was assigned software lead, my next step is to look into writing an emulator for the Intel 8080 CPU, and to start writing it as soon as possible.
			<br>
			<br>
			<br><br>
			
	<!--  Week 1, Entry 1  -->
	<h4><b>Entry 1: -----------------------------------------------------------------</b></h4>
           <b>Date: January 15th </b><br> <!--the date the project meeting or work was performed)-->
            <b>Start Time: 9:30am </b><br> <!--the time you began the meeting/work for this entry-->
            <b>Duration: 2 hours </b><br><br> <!--how long the meeting/work lasted rounded to nearest quarter hour-->
            This was our first lab meeting, so we spent half of the lab section learning about lab resources. The other half of the lab was discussing our project with the TAs and talking about project milestones within our group.
		We mostly just talked about rough milestone ideas without formalizing anything, but we got a rough idea of the various components of our project. This gave us a good foundation to do our own research and figure out exactly what all needed to be done.
		THe next step is to formalize our milestones and assign team roles, so we can start working on the various project components.
			<br>
			<br>
		 <br><br>


		<!--
		*********************************************************************************
		*********************************************************************************
		*********************************************************************************

		
		JOURNAL ENTRIES ABOVE
		Make your Journal Entries in the template area above and copy/paste going forward


		*********************************************************************************
		*********************************************************************************
		*********************************************************************************
		-->


        </div>
	
		<!-- Instantiate global footer. Any changes to the footer should be made through the top-level file "footer.html" -->
		<div id="footer"></div>
    </div>
</div>

<!--JS-->
<script src="js/jquery.js"></script>
<script src="js/jquery-migrate-1.1.1.js"></script>

<script type="text/javascript">
$(document).ready(function() {
    $("#header").load("header.html");
	$("#menu").load("navbar.html");
	$("#footer").load("footer.html");
});
</script>
</body>
</html>
